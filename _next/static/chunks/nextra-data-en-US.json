{"/filter":{"title":"Filter","data":{}},"/":{"title":"Introduction","data":{"":"Spring Cloud Gateway 이모저모\nRate Limiter\nRouter, Filter\n예제 GithubRate Limiter\nhttps://github.com/chagchagchag/example-gateway-rate-limiter\nRouter, Filter\nhttps://github.com/chagchagchag/example-gateway-router-filter-v1"}},"/rate-limiter":{"title":"Rate Limiter","data":{"rate-limiter#Rate Limiter":"","참고#참고":"spring.io/projects/spring-cloud-gateway\nReference Doc","rate-limiter-1#Rate Limiter":"Spring Cloud Gateway 의 Official Page 에서는 주요 Feature 들에 대해서 아래의 내용들을 이야기하고 있습니다.Spring Cloud Gateway features:\nBuilt on Spring Framework and Spring Boot\nAble to match routes on any request attribute.\nPredicates and filters are specific to routes.\nCircuit Breaker integration.\nSpring Cloud DiscoveryClient integration\nEasy to write Predicates and Filters\nRequest Rate Limiting\nPath Rewriting\n이번 카테고리에서는 위의 요소들 중 끝에서 두 번째 요소인 Request Rate Limiting 에 대해서 정리합니다."}},"/rate-limiter/example-rate-limiter":{"title":"Example Rate Limiter","data":{"ratelimiter-예제#RateLimiter 예제":"이번 문서에서는 RateLimiter 예제를 작성하는 과정을 정리해봅니다. 이 예제에 대한 github 리포지터리는 아래의 링크를 참고해주시기 바랍니다.\ngitub.com/chagchagchag/example-gateway-rate-limiter","rate-limit-token-bucket-algorithm#Rate Limit, Token Bucket Algorithm":"Spring Cloud Gateway 는 Router 기능, Rate Limit 을 모두 제공한다는 점에서 꽤 유용하고 다용도의 기능을 제공하는 것 같습니다. Spring Cloud Gateway 에서 제공하는 RateLimiter 의 기본 Rate Limit 정책은 Token Bucket Algorithm 입니다. Token Bucket Algorithm 에 대해서는 아래의 자료에 자세하게 설명되어 있습니다.\nRate limiting using the Token Bucket algorithm\nBucket4j - Token bucket 알고리즘을 이용한 Rate limit 라이브러리를 알아보자!!\n만약 Rate Limit 을 더 효율적으로 하고 싶을 경우 참고해서 튜닝이 이뤄진 Rate Limit 서비스를 만들 수 있을 것 같아서 추가해둔 자료입니다.\nRate Limiter 를 분산환경에서 적용시 일반적으로는 Redis 와 같은 data store 를 이용하게 됩니다. 이 경우 고민해야 할 점으로는 Race Condition 이 발생할 수 있다는 점 역시 어느 정도는 고민에 넣어두어야 할 것 같습니다. 따라서 이 경우 TTL 을 따로 지정해줘서 특정 키값의 만료를 지정한다는가 하는 설정을 따로 해두는 것을 권장합니다.RFC6585 에서는 Rate Limit 적용 시 한계치에 도달했을 때 응답으로 \"429 Too Many Request\" 를 응답하도록 권고하고 있습니다. 그리고 아래의 정보들도 부가적으로 Header 에 같이 전달해주면 좋습니다.\nRateLimit-Used : 기준 시간 단위 API 호출 수\nRateLimit-Limit : 허용되는 요청의 최대 수\nRateLimit-Remaining : 남은 요청 수\nRateLimit-Reset : 요청 최대값이 재설정 될 때 까지의 시간\n참고 : Naver Works Developers > 참고사항 > Rate Limits","foobar-user#foobar-user":"사용자 가입을 위한 서비스를 foobar-user 라는 모듈로 개발중이라고 하겠습니다. foobar-user 모듈의 내용들은 아래와 같습니다.","buildgradlekts#build.gradle.kts":"// ...\r\n\r\nrepositories {\r\n  mavenCentral()\r\n}\r\n\r\nextra[\"springCloudVersion\"] = \"2023.0.1\"\r\n\r\ndependencies {\r\n  implementation(\"org.springframework.boot:spring-boot-starter-data-redis-reactive\")\r\n  implementation(\"org.springframework.boot:spring-boot-starter-web\")\r\n  testImplementation(\"org.springframework.boot:spring-boot-starter-test\")\r\n  testImplementation(\"io.projectreactor:reactor-test\")\r\n}\r\n\r\ndependencyManagement {\r\n  imports {\r\n    mavenBom(\"org.springframework.cloud:spring-cloud-dependencies:${property(\"springCloudVersion\")}\")\r\n  }\r\n}","healthcheckcontrollerjava#HealthcheckController.java":"간단한 HealthcheckController 코드입니다.\npackage io.chagchagchag.example.user.healthcheck;\r\n\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\n@RestController\r\npublic class HealthcheckController {\r\n  @GetMapping(\"/healthcheck/ready\")\r\n  public String getReady(){\r\n    return \"OK\";\r\n  }\r\n}","동작-확인#동작 확인":"curl 명령으로 아래의 명령을 수행해서 Web (8080) 에서 정상적으로 요청 수행이 되는지 테스트해봅니다.\n$ curl localhost:8080/healthcheck/ready\r\nOK","foobar-gateway#foobar-gateway":"위에서 작성한 foobar-user 애플리케이션에 대해 gateway 역할을 수행하는 모듈입니다.","buildgradlekts-1#build.gradle.kts":"// ...\r\n\r\nrepositories {\r\n  mavenCentral()\r\n}\r\n\r\nextra[\"springCloudVersion\"] = \"2023.0.1\"\r\n\r\ndependencies {\r\n  implementation(\"org.springframework.boot:spring-boot-starter-data-redis-reactive\")\r\n  implementation(\"org.springframework.cloud:spring-cloud-starter-gateway\")\r\n  compileOnly(\"org.projectlombok:lombok\")\r\n  annotationProcessor(\"org.projectlombok:lombok\")\r\n  testImplementation(\"org.springframework.boot:spring-boot-starter-test\")\r\n  testImplementation(\"io.projectreactor:reactor-test\")\r\n}\r\n\r\ndependencyManagement {\r\n  imports {\r\n    mavenBom(\"org.springframework.cloud:spring-cloud-dependencies:${property(\"springCloudVersion\")}\")\r\n  }\r\n}\r\n\r\n// ...","applicationyml#application.yml":"yml 파일 내에서 spring.cloud.gateway.routes[0].filters 내에 정의한 RequestRateLimiter 에 대한 args 중 key-resolver 에 대한 값인 \"#{@userIdAsKeyResolver}\" 값은 직접 정의한 Bean 입니다. 뒤에서 설명합니다.\nserver:\r\n  port: 9000\r\n\r\nspring:\r\n  data:\r\n    redis:\r\n      host: localhost\r\n      port: 26379\r\n      database: 0\r\n  cloud:\r\n    gateway:\r\n      routes:\r\n        - id: all\r\n          uri: http://localhost:8080\r\n          predicates:\r\n            - Path=/**\r\n          filters:\r\n            - name: RequestRateLimiter\r\n              args:\r\n                redis-rate-limiter.replenishRate: 20\r\n                redis-rate-limiter.burstCapacity: 100\r\n                redis-rate-limiter.requestedTokens: 3\r\n                key-resolver: \"#{@userIdAsKeyResolver}\"\nreplenishRate : 초당 버킷 회복 량을 의미합니다. 위에서는 20 을 지정했는데 1초 내에 어떤 요청이 7회 발생하면 3x7 = 21 개의 토큰이 소모되며, 1초 뒤에 회복될때는 replenishRate 를 통해 다시 버킷이 30 으로 회복됩니다. (3은 requestedTokens 를 의미합니다.)\nburstCapacitiy : 버킷에 담을 수 있는 최대 양을 의미합니다.\nrequestedTokens : 요청 발생 시마다 소모할 토큰의 갯수를 의미합니다. 3으로 설정했으므로 요청 하나당 3 의 토큰이 소모됩니다.\nkey-resolver : \"#{@userIdKeyResolver}\" 로 지정해줬는데, Java Config 로 미리 정의해둔 \"userIdKeyResolver\" 라는 이름의 Bean 을 의미하는 SPEL 표현식입니다.","useridkeyresolver#UserIdKeyResolver":"사용자가 Request Header 에 전달한 USER-ID 라고 하는 헤더 값을 추출하기 위해 ServerWebExchange 내의 request 내의 Header 내에서 USER-ID 에 대한 값을 추출합니다.그리고 값이 정상일 경우 Mono<String> 을 return 하고 정상이 아닐 경우 Mono.error 를 리턴합니다.\npackage io.chagchagchag.example.gateway.resolver;\r\n\r\nimport java.util.Optional;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.cloud.gateway.filter.ratelimit.KeyResolver;\r\nimport org.springframework.stereotype.Component;\r\nimport org.springframework.web.server.ServerWebExchange;\r\nimport reactor.core.publisher.Mono;\r\n\r\n@Component(\"userIdAsKeyResolver\")\r\npublic class UserIdKeyResolver implements KeyResolver {\r\n  private final Logger logger = LoggerFactory.getLogger(UserIdKeyResolver.class);\r\n  @Override\r\n  public Mono<String> resolve(ServerWebExchange exchange) {\r\n    final String userId = exchange.getRequest()\r\n        .getHeaders()\r\n        .getFirst(\"USER-ID\");\r\n\r\n    return Optional.ofNullable(userId)\r\n        .map(Mono::justOrEmpty)\r\n        .orElseGet(() -> {\r\n          exchange.getResponse().setComplete();\r\n          logger.debug(\">>> 'USER-ID' is Empty\");\r\n          return Mono.error(new IllegalArgumentException(\"존재하지 않는 아이디입니다.\"));\r\n        });\r\n  }\r\n}","동작-확인-1#동작 확인":"먼저 foobar-user 를 기동시킵니다.\n그리고 foobar-gateway 를 기동시킵니다.\ncurl 명령으로 아래의 명령을 수행해서 Gateway 에서 정상적으로 동작하는지 확인합니다.\n$ curl -X GET localhost:9000/healthcheck/ready -H \"Content-Type: application/json\" -H \"USER-ID:'A'\"\r\nOK","curl-명령어#curl 명령어":"주로 http 파일을 쓰거나 springdoc 를 사용하는 편이지만, 간단한 테스트는 curl 로만 수행하는게 오히려 더 편할 때가 많습니다. 그래서 막간을 이용해서 curl 명령어를 정리해봅니다.curl 명령어 사용시 자주 사용하는 옵션은 3가지 입니다.\n-d, --data : \"data\" 를 의미합니다.\n-H, --header : \"header\" 를 의미합니다. 리퀘스트 전송시 헤더에 특정 값을 전달해야 할 경우 -H 를 지정해줍니다.\n-X, --request : 사용할 요청 메서드(GET, POST, PUT 등)를 명시해주기 위해 사용하는 옵션입니다.\n예를 들어 curl 명령어로 GET 요청을 하는데, 헤더에 USER-ID : A 를 전달해주려고 한다면 아래의 명령을 수행하면 됩니다.\n$ curl -X GET localhost:8080/healthcheck/ready -H \"Content-Type: application/json\" -d \"{\"USER-ID\": \"A\"}\"\r\nOK","e2e-테스트#e2e 테스트":"먼저 테스트를 위해 application.yml 내의 설정을 아래와 같이 바꿔줍니다. 그리고 Gateway Application 을 재기동해줍니다.\nserver:\r\n  port: 9000\r\n\r\nspring:\r\n  data:\r\n    redis:\r\n      host: localhost\r\n      port: 26379\r\n      database: 0\r\n  cloud:\r\n    gateway:\r\n      routes:\r\n        - id: all\r\n          uri: http://localhost:8080\r\n          predicates:\r\n            - Path=/**\r\n          filters:\r\n            - name: RequestRateLimiter\r\n              args:\r\n                redis-rate-limiter.replenishRate: 1\r\n                redis-rate-limiter.burstCapacity: 10\r\n                redis-rate-limiter.requestedTokens: 2\r\n                key-resolver: \"#{@userIdAsKeyResolver}\"\nburstCapacity 를 10초로 했고, requestedTokens 는 2로 설정해서 한 번의 요청에 토큰이 2개 소모되게끔 해주었습니다. 초당 버킷 회복량인 replenishRate 는 1 로 지정해서 버킷이 1초에 1정도가 회복되게끔 해줬습니다.curl 요청 테스트 스크립트 작성curl 요청을 0.5 초에 한번씩 30번 수행하는 스크립트입니다. replenishRate 는 1이므로 1초마다 1정도가 버킷에서 회복되고 requestesTokens 는 2 이므로 0.5초에 2번의 요청이 발생하면 4 개의 Token 이 1초에 한번씩 소모됩니다. 따라서 10 - 4 = 6 이 되고, 1초에 한번씩 버킷 사이즈는 6이 되었다가 다시 10으로 회복되는 방식입니다.curl 스크립트는 아래와 같습니다.\nfor((i=0; i<30; i++)); do\r\n  sleep .5\r\n  curl -X GET localhost:9000/healthcheck/ready -H \"Content-Type: application/json\" -H \"USER-ID:'A'\";\r\ndone\n결론적으로는 버킷이 1초에 2개의 요청을 수행하기에 총 15번의 요청이 성공하게 됩니다.수행 결과\n$ source curl-request-finite.sh \r\nOKOKOKOKOKOKOKOKOKOKOKOKOKOKOK"}},"/rate-limiter/in-my-opinion":{"title":"In My Opinion","data":{"개인적인-생각#개인적인 생각":"주요 테크회사 들 에서는 RateLimiter 를 정교하게 구현해서 사용하고 있을 것으로 추측됩니다. 기본으로 제공되는 lua 스크립트의 경우 나쁜 것은 아닌데 회사의 비즈니스 요구사항에 맞는 요청 유입량 제어 알고리즘이 필요할 것입니다.기본 옵션이 적용된 채로 RateLimiter 를 배포하는 것은 초기 개발 중에는 가능하겠지만, 그 이후부터는 세세한 컨트롤을 위해서는 커스터마이징이 필요해집니다. 예를 들면 RateLimiter 알고리즘도 5개가 넘는 다양한 알고리즘이 존재합니다. 이런 알고리즘 들을 기본으로 설정된 스크립트를 그냥 사용하기에는 아쉽습니다. 토큰 버킷 알고리즘이 적용된 lua 스크립트를 보더라도 Redis 2.6.2 이후로 Deprecated 된 명령어를 그대로 사용하고 있습니다.각 비즈니스마다 수용해야 하는 트래픽의 특성도 여러가지 입니다. 이런 이유로 가급적이면 Rate Limiter 를 커스터마이징해서 사용하는 것이 필요해보입니다. RedisRateLimiter 에 내장된 request_rate_limiter.lua 를 그대로 사용하기보다는 꼭 필요한 Rate Limiter 알고리즘을 lua 스크립트로 개발해서 사용하는 것을 추천드립니다."}},"/rate-limiter/example-custom-rate-limiter":{"title":"Example Custom Rate Limiter","data":{"custom-rate-limiter-예제#Custom Rate Limiter 예제":"이번 문서에서는 Custom 한 RateLimiter 예제를 작성하는 과정을 정리해봅니다. 이 예제에 대한 github 리포지터리는 아래의 링크를 참고해주시기 바랍니다.\ngitub.com/chagchagchag/example-gateway-rate-limiter\n기본으로 제공되는 Rate Limiter 는 Rate Limit 을 넘어갔을 때 응답이 내부적으로 정해진 방식으로만 응답될 수 밖에 없습니다. 하지만, 응답코드, 응답본문, 응답 메시지를 직접 정한 방식으로 내보내려 할 경우 Custom Rate Limiter 를 사용하게 됩니다.오늘 문서는 Custom Rate Limiter 를 작성하는 과정과 End to End 테스트를 해본 과정을 정리합니다.","rate-limit-token-bucket-algorithm#Rate Limit, Token Bucket Algorithm":"Spring Cloud Gateway 는 Router 기능, Rate Limit 을 모두 제공한다는 점에서 꽤 유용하고 다용도의 기능을 제공하는 것 같습니다. Spring Cloud Gateway 에서 제공하는 RateLimiter 의 기본 Rate Limit 정책은 Token Bucket Algorithm 입니다. Token Bucket Algorithm 에 대해서는 아래의 자료에 자세하게 설명되어 있습니다.\nRate limiting using the Token Bucket algorithm\nBucket4j - Token bucket 알고리즘을 이용한 Rate limit 라이브러리를 알아보자!!\n만약 Rate Limit 을 더 효율적으로 하고 싶을 경우 참고해서 튜닝이 이뤄진 Rate Limit 서비스를 만들 수 있을 것 같아서 추가해둔 자료입니다.\nRate Limiter 를 분산환경에서 적용시 일반적으로는 Redis 와 같은 data store 를 이용하게 됩니다. 이 경우 고민해야 할 점으로는 Race Condition 이 발생할 수 있다는 점 역시 어느 정도는 고민에 넣어두어야 할 것 같습니다. 따라서 이 경우 TTL 을 따로 지정해줘서 특정 키값의 만료를 지정한다는가 하는 설정을 따로 해두는 것을 권장합니다.RFC6585 에서는 Rate Limit 적용 시 한계치에 도달했을 때 응답으로 \"429 Too Many Request\" 를 응답하도록 권고하고 있습니다. 그리고 아래의 정보들도 부가적으로 Header 에 같이 전달해주면 좋습니다.\nRateLimit-Used : 기준 시간 단위 API 호출 수\nRateLimit-Limit : 허용되는 요청의 최대 수\nRateLimit-Remaining : 남은 요청 수\nRateLimit-Reset : 요청 최대값이 재설정 될 때 까지의 시간\n참고 : Naver Works Developers > 참고사항 > Rate Limits","foobar-user#foobar-user":"사용자 가입을 위한 서비스를 foobar-user 라는 모듈로 개발중이라고 하겠습니다. foobar-user 모듈의 내용들은 아래와 같습니다.","buildgradlekts#build.gradle.kts":"// ...\r\n\r\nrepositories {\r\n  mavenCentral()\r\n}\r\n\r\nextra[\"springCloudVersion\"] = \"2023.0.1\"\r\n\r\ndependencies {\r\n  implementation(\"org.springframework.boot:spring-boot-starter-data-redis-reactive\")\r\n  implementation(\"org.springframework.boot:spring-boot-starter-web\")\r\n  testImplementation(\"org.springframework.boot:spring-boot-starter-test\")\r\n  testImplementation(\"io.projectreactor:reactor-test\")\r\n}\r\n\r\ndependencyManagement {\r\n  imports {\r\n    mavenBom(\"org.springframework.cloud:spring-cloud-dependencies:${property(\"springCloudVersion\")}\")\r\n  }\r\n}","healthcheckcontrollerjava#HealthcheckController.java":"간단한 HealthcheckController 코드입니다.\npackage io.chagchagchag.example.user.healthcheck;\r\n\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\n@RestController\r\npublic class HealthcheckController {\r\n  @GetMapping(\"/healthcheck/ready\")\r\n  public String getReady(){\r\n    return \"OK\";\r\n  }\r\n}","동작-확인#동작 확인":"curl 명령으로 아래의 명령을 수행해서 Web (8080) 에서 정상적으로 요청 수행이 되는지 테스트해봅니다.\n$ curl localhost:8080/healthcheck/ready\r\nOK","foobar-gateway#foobar-gateway":"위에서 작성한 foobar-user 애플리케이션에 대해 gateway 역할을 수행하는 모듈입니다.","buildgradlekts-1#build.gradle.kts":"// ...\r\n\r\nrepositories {\r\n  mavenCentral()\r\n}\r\n\r\nextra[\"springCloudVersion\"] = \"2023.0.1\"\r\n\r\ndependencies {\r\n  implementation(\"org.springframework.boot:spring-boot-starter-data-redis-reactive\")\r\n  implementation(\"org.springframework.cloud:spring-cloud-starter-gateway\")\r\n  compileOnly(\"org.projectlombok:lombok\")\r\n  annotationProcessor(\"org.projectlombok:lombok\")\r\n  testImplementation(\"org.springframework.boot:spring-boot-starter-test\")\r\n  testImplementation(\"io.projectreactor:reactor-test\")\r\n}\r\n\r\ndependencyManagement {\r\n  imports {\r\n    mavenBom(\"org.springframework.cloud:spring-cloud-dependencies:${property(\"springCloudVersion\")}\")\r\n  }\r\n}\r\n\r\n// ...","applicationyml#application.yml":"yml 파일 내에서 spring.cloud.gateway.routes[0].filters 내에 정의한 RequestRateLimiter 에 대한 args 중 key-resolver 에 대한 값인 \"#{@userIdAsKeyResolver}\" 값은 직접 정의한 Bean 입니다. 뒤에서 설명합니다.\nserver:\r\n  port: 9000\r\n\r\nspring:\r\n  data:\r\n    redis:\r\n      host: localhost\r\n      port: 26379\r\n      database: 0\r\n  cloud:\r\n    gateway:\r\n      routes:\r\n        - id: all\r\n          uri: http://localhost:8080\r\n          predicates:\r\n            - Path=/**\r\n          filters:\r\n            - name: CustomRedisRateLimitFilter\r\n              args:\r\n                redis-rate-limiter.replenishRate: 20\r\n                redis-rate-limiter.burstCapacity: 100\r\n                redis-rate-limiter.requestedTokens: 3\r\n                key-resolver: \"#{@userIdAsKeyResolver}\"\nreplenishRate : 초당 버킷 회복 량을 의미합니다. 위에서는 100 을 지정했는데 1초 내에 어떤 요청이 90회 발생하면, 100을 채워주므로 1초 되에 다시 버킷이 100 으로 회복됩니다.\nburstCapacitiy : 버킷에 담을 수 있는 최대 양을 의미합니다.\nrequestedTokens : 요청 시에 소모할 토큰의 갯수를 의미합니다. 3으로 설정했으므로 요청 하나당 3 의 토큰이 소모됩니다.\nkey-resolver : \"#{@userIdKeyResolver}\" 로 지정해줬는데, Java Config 로 미리 정의해둔 \"userIdKeyResolver\" 라는 이름의 Bean 을 의미하는 SPEL 표현식입니다.","useridkeyresolver#UserIdKeyResolver":"사용자가 Request Header 에 전달한 USER-ID 라고 하는 헤더 값을 추출하기 위해 ServerWebExchange 내의 request 내의 Header 내에서 USER-ID 에 대한 값을 추출합니다.그리고 값이 정상일 경우 Mono<String> 을 return 하고 정상이 아닐 경우 Mono.error 를 리턴합니다.\npackage io.chagchagchag.example.gateway.resolver;\r\n\r\nimport java.util.Optional;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.cloud.gateway.filter.ratelimit.KeyResolver;\r\nimport org.springframework.stereotype.Component;\r\nimport org.springframework.web.server.ServerWebExchange;\r\nimport reactor.core.publisher.Mono;\r\n\r\n@Component(\"userIdAsKeyResolver\")\r\npublic class UserIdKeyResolver implements KeyResolver {\r\n  private final Logger logger = LoggerFactory.getLogger(UserIdKeyResolver.class);\r\n  @Override\r\n  public Mono<String> resolve(ServerWebExchange exchange) {\r\n    final String userId = exchange.getRequest()\r\n        .getHeaders()\r\n        .getFirst(\"USER-ID\");\r\n\r\n    return Optional.ofNullable(userId)\r\n        .map(Mono::justOrEmpty)\r\n        .orElseGet(() -> {\r\n          exchange.getResponse().setComplete();\r\n          logger.debug(\">>> 'USER-ID' is Empty\");\r\n          return Mono.error(new IllegalArgumentException(\"존재하지 않는 아이디입니다.\"));\r\n        });\r\n  }\r\n}","customredisratelimitfilter#CustomRedisRateLimitFilter":"AbstractGatewayFilterFactory<T> 를 상속한 별도의 Filter 를 생성했고 이 것의 역할은 Redis 를 이용해 Custom 한 Rate Limiter 역할을 수행하는 것입니다.\npackage io.chagchagchag.example.gateway.filter;\r\n\r\nimport io.chagchagchag.example.gateway.resolver.UserIdKeyResolver;\r\nimport java.nio.charset.StandardCharsets;\r\nimport lombok.Getter;\r\nimport lombok.Setter;\r\nimport org.springframework.cloud.gateway.filter.GatewayFilter;\r\nimport org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;\r\nimport org.springframework.cloud.gateway.filter.ratelimit.KeyResolver;\r\nimport org.springframework.cloud.gateway.filter.ratelimit.RateLimiter;\r\nimport org.springframework.cloud.gateway.filter.ratelimit.RedisRateLimiter;\r\nimport org.springframework.cloud.gateway.support.HasRouteId;\r\nimport org.springframework.http.HttpStatus;\r\nimport org.springframework.http.MediaType;\r\nimport org.springframework.http.server.reactive.ServerHttpResponse;\r\nimport org.springframework.stereotype.Component;\r\nimport reactor.core.publisher.Mono;\r\n\r\n@Component\r\npublic class CustomRedisRateLimitFilter extends AbstractGatewayFilterFactory<CustomRedisRateLimitFilter.Config> {\r\n  private final RateLimiter<RedisRateLimiter.Config> rateLimiter;\r\n  private final UserIdKeyResolver userIdKeyResolver;\r\n\r\n  public CustomRedisRateLimitFilter(\r\n      RateLimiter<RedisRateLimiter.Config> rateLimiter,\r\n      UserIdKeyResolver userIdKeyResolver\r\n  ) {\r\n    super(Config.class);\r\n    this.rateLimiter = rateLimiter;\r\n    this.userIdKeyResolver = userIdKeyResolver;\r\n  }\r\n\r\n  @Override\r\n  public GatewayFilter apply(Config config) {\r\n    return (exchange, chain) -> {\r\n      var response = exchange.getResponse();\r\n      var keyResolver = config.keyResolver;\r\n      var routeId = config.routeId;\r\n\r\n      return keyResolver.resolve(exchange)\r\n          .flatMap(key -> this.rateLimiter.isAllowed(routeId, key))\r\n          .flatMap(rateLimitResponse -> {\r\n            boolean allowed = rateLimitResponse.isAllowed();\r\n            if(allowed) return chain.filter(exchange);\r\n            else return responseTooManyRequest(response);\r\n          });\r\n    };\r\n  }\r\n\r\n  public Mono<Void> responseTooManyRequest(ServerHttpResponse response){\r\n    response.setStatusCode(HttpStatus.TOO_MANY_REQUESTS);\r\n    response.getHeaders().setContentType(MediaType.APPLICATION_JSON);\r\n    return response.writeWith(\r\n        Mono.just(\r\n            response.bufferFactory().wrap(\r\n                \"\"\"\r\n                |\"success\": false,\r\n                |\"message\": \"Too Many Requests\"\r\n                \"\"\".trim().getBytes(StandardCharsets.UTF_8)\r\n            )\r\n        )\r\n    );\r\n  }\r\n\r\n  @Getter @Setter\r\n  static class Config implements HasRouteId {\r\n    private KeyResolver keyResolver;\r\n    private String routeId;\r\n\r\n    public Config(){}\r\n\r\n    public Config(KeyResolver keyResolver){\r\n      this.keyResolver = keyResolver;\r\n    }\r\n\r\n    public Config(\r\n        KeyResolver keyResolver,\r\n        String routeId\r\n    ){\r\n      this.keyResolver = keyResolver;\r\n      this.routeId = routeId;\r\n    }\r\n\r\n    @Override\r\n    public void setRouteId(String routeId) {\r\n      this.routeId = routeId;\r\n    }\r\n\r\n    @Override\r\n    public String getRouteId() {\r\n      return routeId;\r\n    }\r\n  }\r\n}","동작-확인-1#동작 확인":"먼저 foobar-user 를 기동시킵니다.\n그리고 foobar-gateway 를 기동시킵니다.\ncurl 명령으로 아래의 명령을 수행해서 Gateway 에서 정상적으로 동작하는지 확인합니다.\n$ curl -X GET localhost:9000/healthcheck/ready -H \"Content-Type: application/json\" -H \"USER-ID:'A'\"\r\nOK","curl-명령어#curl 명령어":"주로 http 파일을 쓰거나 springdoc 를 사용하는 편이지만, 간단한 테스트는 curl 로만 수행하는게 오히려 더 편할 때가 많습니다. 그래서 막간을 이용해서 curl 명령어를 정리해봅니다.curl 명령어 사용시 자주 사용하는 옵션은 3가지 입니다.\n-d, --data : \"data\" 를 의미합니다.\n-H, --header : \"header\" 를 의미합니다. 리퀘스트 전송시 헤더에 특정 값을 전달해야 할 경우 -H 를 지정해줍니다.\n-X, --request : 사용할 요청 메서드(GET, POST, PUT 등)를 명시해주기 위해 사용하는 옵션입니다.\n예를 들어 curl 명령어로 GET 요청을 하는데, 헤더에 USER-ID : A 를 전달해주려고 한다면 아래의 명령을 수행하면 됩니다.\n$ curl -X GET localhost:8080/healthcheck/ready -H \"Content-Type: application/json\" -d \"{\"USER-ID\": \"A\"}\"\r\nOK","e2e-테스트#e2e 테스트":"먼저 테스트를 위해 application.yml 내의 설정을 아래와 같이 바꿔줍니다. 그리고 Gateway Application 을 재기동해줍니다. Filter 를 CustomRedisRateLimitFilter 을 사용하도록 지정해줬습니다.\nserver:\r\n  port: 9000\r\n\r\nspring:\r\n  data:\r\n    redis:\r\n      host: localhost\r\n      port: 26379\r\n      database: 0\r\n  cloud:\r\n    gateway:\r\n      routes:\r\n        - id: all\r\n          uri: http://localhost:8080\r\n          predicates:\r\n            - Path=/**\r\n          filters:\r\n#            - name: RequestRateLimiter\r\n            - name: CustomRedisRateLimitFilter\r\n              args:\r\n                redis-rate-limiter.replenishRate: 1\r\n                redis-rate-limiter.burstCapacity: 10\r\n                redis-rate-limiter.requestedTokens: 2\r\n                key-resolver: \"#{@userIdAsKeyResolver}\"\nburstCapacity 를 10초로 했고, requestedTokens 는 2로 설정해서 한 번의 요청에 토큰이 2개 소모되게끔 해주었습니다. 초당 버킷 회복량인 replenishRate 는 1 로 지정해서 버킷이 1초에 1정도가 회복되게끔 해줬습니다.curl 요청 테스트 스크립트 작성curl 요청을 0.5 초에 한번씩 30번 수행하는 스크립트입니다. replenishRate 는 1이므로 1초마다 1정도가 버킷에서 회복되고 requestesTokens 는 2 이므로 0.5초에 2번의 요청이 발생하면 4 개의 Token 이 1초에 한번씩 소모됩니다. 따라서 10 - 4 = 6 이 되고, 1초에 한번씩 버킷 사이즈는 6이 되었다가 다시 10으로 회복되는 방식입니다.curl 스크립트는 아래와 같습니다.\nfor((i=0; i<30; i++)); do\r\n  sleep .5\r\n  curl -X GET localhost:9000/healthcheck/ready -H \"Content-Type: application/json\" -H \"USER-ID:'A'\";\r\ndone\n실행결과실행결과를 보면 의도한대로 15개의 요청이 성공했으며, 이외의 요청들은 모두 Too Many Requests 라는 응답을 받았음을 확인 가능합니다.\n$ source curl-request-finite.sh \r\nOKOKOKOKOKOKOK|\"success\": false,\r\n|\"message\": \"Too Many Requests\"OK|\"success\": false,\r\n|\"message\": \"Too Many Requests\"|\"success\": false,\r\n|\"message\": \"Too Many Requests\"OK|\"success\": false,\r\n|\"message\": \"Too Many Requests\"|\"success\": false,\r\n|\"message\": \"Too Many Requests\"OK|\"success\": false,\r\n|\"message\": \"Too Many Requests\"OK|\"success\": false,\r\n|\"message\": \"Too Many Requests\"|\"success\": false,\r\n|\"message\": \"Too Many Requests\"OK|\"success\": false,\r\n|\"message\": \"Too Many Requests\"|\"success\": false,\r\n|\"message\": \"Too Many Requests\"OK|\"success\": false,\r\n|\"message\": \"Too Many Requests\"|\"success\": false,\r\n|\"message\": \"Too Many Requests\"OK|\"success\": false,\r\n|\"message\": \"Too Many Requests\"|\"success\": false,\r\n|\"message\": \"Too Many Requests\"OK|\"success\": false,\r\n|\"message\": \"Too Many Requests\"","성능부하테스트#성능/부하테스트":"정리 예정!!"}},"/rate-limiter/inside-redis-rate-limiter":{"title":"Inside Redis Rate Limiter","data":{"redisratelimiter-의-내부-동작#RedisRateLimiter 의 내부 동작":"","requestratelimitergatewayfilterfactory#RequestRateLimiterGatewayFilterFactory":"참고\nspring-cloud-gateway-server/src/main/java/org/springframework/cloud/gateway/filter/ratelimit\nRequestRateLimiterGatewayFilterFactory\nGatewayFilter\nKeyResolver\nGatewayAutoConfiguration","생성자#생성자":"RequestRateLimiterGatewayFilterFactory 는 GatewayFilter 객체를 생성하는 역할을 합니다. RequestRateLimiterGatewayFilterFactory 의 생성자 코드는 아래와 같습니다.\n// ...\r\n\r\n@ConfigurationProperties(\"spring.cloud.gateway.filter.request-rate-limiter\")\r\npublic class RequestRateLimiterGatewayFilterFactory\r\n\t\textends AbstractGatewayFilterFactory<RequestRateLimiterGatewayFilterFactory.Config> {\r\n    // ...\r\n    private final RateLimiter defaultRateLimiter;\r\n\tprivate final KeyResolver defaultKeyResolver;\r\n    \r\n    public RequestRateLimiterGatewayFilterFactory(RateLimiter defaultRateLimiter, KeyResolver defaultKeyResolver) {\r\n\t\tsuper(Config.class);\r\n\t\tthis.defaultRateLimiter = defaultRateLimiter;\r\n\t\tthis.defaultKeyResolver = defaultKeyResolver;\r\n\t}\r\n}\ndefaultRateLimiter, defaultKeyResolver 는 사용자가 별도로 defaultRateLimiter, defaultKeyResolver 를 주입하지 않으면 Spring Cloud Gateway 내부적으로 의존성 주입을 합니다.만약 RequestRateLimitGatewayFilterFactory 의 생성자를 이용해서 @Bean 설정을 직접 한다면, 위의 생성자를 통해서 객체를 생성해서 @Bean 으로 등록하며 defaultRateLimiter, defaultKeyResolver 에 해당하는 인자값에 실제 객체를 주입해주면 됩니다.","applyconfig#apply(Config)":"이번에는 apply(Config) 메서드를 살펴봅니다.뭔가 굉장히 어려운 내용인 것 같지만 그렇게 대단한 코드는 없습니다.\n@ConfigurationProperties(\"spring.cloud.gateway.filter.request-rate-limiter\")\r\npublic class RequestRateLimiterGatewayFilterFactory\r\n\t\textends AbstractGatewayFilterFactory<RequestRateLimiterGatewayFilterFactory.Config> {\r\n    // ...\r\n    \r\n    @SuppressWarnings(\"unchecked\")\r\n\t@Override\r\n\tpublic GatewayFilter apply(Config config) {\r\n\t\tKeyResolver resolver = getOrDefault(config.keyResolver, defaultKeyResolver);\r\n\t\tRateLimiter<Object> limiter = getOrDefault(config.rateLimiter, defaultRateLimiter);\r\n\t\tboolean denyEmpty = getOrDefault(config.denyEmptyKey, this.denyEmptyKey);\r\n\t\tHttpStatusHolder emptyKeyStatus = HttpStatusHolder\r\n\t\t\t\t.parse(getOrDefault(config.emptyKeyStatus, this.emptyKeyStatusCode));\r\n\r\n        // 1)\r\n\t\treturn (exchange, chain) -> resolver.resolve(exchange).defaultIfEmpty(EMPTY_KEY).flatMap(key -> {\r\n\t\t\tif (EMPTY_KEY.equals(key)) {\r\n\t\t\t\tif (denyEmpty) {\r\n\t\t\t\t\tsetResponseStatus(exchange, emptyKeyStatus);\r\n\t\t\t\t\treturn exchange.getResponse().setComplete();\r\n\t\t\t\t}\r\n\t\t\t\treturn chain.filter(exchange);\r\n\t\t\t}\r\n\t\t\tString routeId = config.getRouteId();\r\n            // 2) \r\n\t\t\tif (routeId == null) {\r\n\t\t\t\tRoute route = exchange.getAttribute(ServerWebExchangeUtils.GATEWAY_ROUTE_ATTR);\r\n\t\t\t\trouteId = route.getId();\r\n\t\t\t}\r\n            // 3)\r\n\t\t\treturn limiter.isAllowed(routeId, key).flatMap(response -> {\r\n\r\n                // 3-1)\r\n\t\t\t\tfor (Map.Entry<String, String> header : response.getHeaders().entrySet()) {\r\n\t\t\t\t\texchange.getResponse().getHeaders().add(header.getKey(), header.getValue());\r\n\t\t\t\t}\r\n                // 3-2)\r\n\t\t\t\tif (response.isAllowed()) {\r\n\t\t\t\t\treturn chain.filter(exchange);\r\n\t\t\t\t}\r\n                // 3-3)\r\n\t\t\t\tsetResponseStatus(exchange, config.getStatusCode());\r\n\t\t\t\treturn exchange.getResponse().setComplete();\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n    \r\n    private <T> T getOrDefault(T configValue, T defaultValue) {\r\n\t\treturn (configValue != null) ? configValue : defaultValue;\r\n\t}\r\n    \r\n    // ...\r\n    \r\n}\n참고\nKeyResolver\nServerWebExchangeUtils - GATEWAY_ROUTE_ATTR\n1)\nExchange 를 KeyResolver 로 resolve() 한 결과가 null 이면 EMPTY_KEY 를 return 하고, 그 외의 경우는 flatMap(...) 을 통해 다음 처리로 넘어갑니다.\n2) routeId 가 null 일 경우에 대한 설정입니다.\nServerWebExchangeUtils 에 정의된 키에 대해 Spring Webflux 의 ServerWebExchange 에 기본설정된 Gateway Router 에 대한 어트리뷰트 값(Value)을 얻어냅니다. 그리고 이 값은 Route 객체인데 이 기본 객체에 대한 routeId 를 얻어냅니다.\n3) RateLimiter::isAllowed(routerId, key) 를 통해 얻어낸 Mono<Response> 를 flatMap 처리합니다. RateLimiter::isAllowed(routerId, key) 메서드는 뒤에서 정리합니다.\n3-1) RateLimiter::isAllowed(routerId, key) 에서 만들어낸 Response 객체 내의 header 의 Key, Value 의 쌍 들을 모두 복사해서 Exchange 내의 header 에 복제합니다.\n3-2) RateLimiter::isAllowed(routerId, key) 에서 만들어낸 Response 객체가 isAllowed 된 객체라면 chain.filter(exchange) 를 통해 다음 Filter 처리를 하도록 DispatcherHandler 에게 전달합니다.\n3-3) RateLimiter::isAllowed(routerId, key) 에서 만들어낸 Response 객체가 isAllowed가 아니라면 별도로 responseStatus 를 세팅하고, exchange 의 response 의 상태를 complete 로 변경합니다.","ratelimiter#RateLimiter":"RateLimiter\nAbstractRateLimiter : AbstractRateLimiter 의 내부 구현에 대해서는 설명을 생략합니다.\nRateLimiter 는 interface 입니다. 이 interface 를 구현해서 필요에 맞게 다양한 구현체를 적용가능합니다. Spring Cloud Gateway 는 Redis 를 사용하는데, Spring Cloud Gateway 는 RateLimiter 에 대한 구현체로 RedisRateLimiter 를 채택하고 있습니다.AbstractRateLimiter 에서는 RateLimiter 를 구현하는 데에 있어서 필요한 필수적인 로직들을 구현하고 있는 abstract 클래스입니다.RateLimiter interface 의 내용은 아래와 같습니다.\npackage org.springframework.cloud.gateway.filter.ratelimit;\r\n\r\npublic interface RateLimiter<C> extends StatefulConfigurable<C> {\r\n\r\n\tMono<Response> isAllowed(String routeId, String id);\r\n\r\n\tclass Response {\r\n\r\n\t\tprivate final boolean allowed;\r\n\r\n\t\tprivate final long tokensRemaining;\r\n\r\n\t\tprivate final Map<String, String> headers;\r\n\r\n\t\tpublic Response(boolean allowed, Map<String, String> headers) {\r\n\t\t\tthis.allowed = allowed;\r\n\t\t\tthis.tokensRemaining = -1;\r\n\t\t\tAssert.notNull(headers, \"headers may not be null\");\r\n\t\t\tthis.headers = headers;\r\n\t\t}\r\n\r\n\t\tpublic boolean isAllowed() {\r\n\t\t\treturn allowed;\r\n\t\t}\r\n\r\n\t\tpublic Map<String, String> getHeaders() {\r\n\t\t\treturn Collections.unmodifiableMap(headers);\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String toString() {\r\n\t\t\tfinal StringBuffer sb = new StringBuffer(\"Response{\");\r\n\t\t\tsb.append(\"allowed=\").append(allowed);\r\n\t\t\tsb.append(\", headers=\").append(headers);\r\n\t\t\tsb.append(\", tokensRemaining=\").append(tokensRemaining);\r\n\t\t\tsb.append('}');\r\n\t\t\treturn sb.toString();\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\nResponse 라고 하는 Response 데이터를 담는용도의 클래스가 정의되어 있으며, isAllowed(routeId, id) 를 메서드로 제공하고 있습니다.","redisratelimiter#RedisRateLimiter":"AbstractRateLimiter : AbstractRateLimiter 의 내부 구현에 대해서는 생략합니다.\nRedisRateLimiter\nRedisRateLimiter 의 내용 중 이번 문서에서는 isAllowed(), lua 스크립트 를 알아볼 예정입니다.\nisAllowed() 메서드\nlua 스크립트","redisratelimiterisallowed-메서드#RedisRateLimiter::isAllowed() 메서드":"RedisRateLimiter::isAllowed() 메서드 는 아래와 같이 정의되어 있습니다. 꽤 복잡해보이지만 크게 복잡한 내용은 없습니다.\npackage org.springframework.cloud.gateway.filter.ratelimit;\r\n// ...\r\n\r\n@ConfigurationProperties(\"spring.cloud.gateway.redis-rate-limiter\")\r\npublic class RedisRateLimiter extends AbstractRateLimiter<RedisRateLimiter.Config> implements ApplicationContextAware {\r\n    \r\n    // ...\r\n    private RedisScript<List<Long>> script;\r\n    \r\n    // ...\r\n    public RedisRateLimiter(ReactiveStringRedisTemplate redisTemplate, RedisScript<List<Long>> script,\r\n\t\t\tConfigurationService configurationService) {\r\n\t\tsuper(Config.class, CONFIGURATION_PROPERTY_NAME, configurationService);\r\n\t\tthis.redisTemplate = redisTemplate;\r\n\t\tthis.script = script;\r\n\t\tthis.initialized.compareAndSet(false, true);\r\n\t}\r\n    \r\n    // ...\r\n    \r\n    @Override\r\n\t@SuppressWarnings(\"unchecked\")\r\n\tpublic Mono<Response> isAllowed(String routeId, String id) {\r\n\t\tif (!this.initialized.get()) {\r\n\t\t\tthrow new IllegalStateException(\"RedisRateLimiter is not initialized\");\r\n\t\t}\r\n\r\n\t\tConfig routeConfig = loadConfiguration(routeId);\r\n\r\n        // (0)\r\n\t\t// How many requests per second do you want a user to be allowed to do?\r\n\t\tint replenishRate = routeConfig.getReplenishRate();\r\n\r\n\t\t// How much bursting do you want to allow?\r\n\t\tint burstCapacity = routeConfig.getBurstCapacity();\r\n\r\n\t\t// How many tokens are requested per request?\r\n\t\tint requestedTokens = routeConfig.getRequestedTokens();\r\n\r\n\t\ttry {\r\n\t\t\tList<String> keys = getKeys(id);\r\n\r\n            // (1)\r\n\t\t\t// The arguments to the LUA script. time() returns unixtime in seconds.\r\n\t\t\tList<String> scriptArgs = Arrays.asList(replenishRate + \"\", burstCapacity + \"\",\r\n\t\t\t\t\tInstant.now().getEpochSecond() + \"\", requestedTokens + \"\");\r\n            \r\n            // (2)\r\n\t\t\t// allowed, tokens_left = redis.eval(SCRIPT, keys, args)\r\n\t\t\tFlux<List<Long>> flux = this.redisTemplate.execute(this.script, keys, scriptArgs);\r\n\t\t\t// .log(\"redisratelimiter\", Level.FINER);\r\n\t\t\treturn flux.onErrorResume(throwable -> {\r\n\t\t\t\tif (log.isDebugEnabled()) {\r\n\t\t\t\t\tlog.debug(\"Error calling rate limiter lua\", throwable);\r\n\t\t\t\t}\r\n\t\t\t\treturn Flux.just(Arrays.asList(1L, -1L));\r\n\t\t\t}).reduce(new ArrayList<Long>(), (longs, l) -> {\r\n\t\t\t\tlongs.addAll(l);\r\n\t\t\t\treturn longs;\r\n\t\t\t}).map(results -> {\r\n\t\t\t\tboolean allowed = results.get(0) == 1L;\r\n\t\t\t\tLong tokensLeft = results.get(1);\r\n\r\n\t\t\t\tResponse response = new Response(allowed, getHeaders(routeConfig, tokensLeft));\r\n\r\n\t\t\t\tif (log.isDebugEnabled()) {\r\n\t\t\t\t\tlog.debug(\"response: \" + response);\r\n\t\t\t\t}\r\n\t\t\t\treturn response;\r\n\t\t\t});\r\n\t\t}\r\n\t\tcatch (Exception e) {\r\n\t\t\t/*\r\n\t\t\t * We don't want a hard dependency on Redis to allow traffic. Make sure to set\r\n\t\t\t * an alert so you know if this is happening too much. Stripe's observed\r\n\t\t\t * failure rate is 0.01%.\r\n\t\t\t */\r\n\t\t\tlog.error(\"Error determining if user allowed from redis\", e);\r\n\t\t}\r\n\t\treturn Mono.just(new Response(true, getHeaders(routeConfig, -1L)));\r\n\t}\r\n}\n(0)\nreplenishRate, burstCapacity, requestedTokens 와 같은 값들을 routeConfig 에서 가져옵니다. burstCapacity, replenishRate, requestedTokens 등과 같은 값들은 모두 개발자가 선언한 application.yml 파일에 정의되어 있는 내용입니다.\n(1)\n(0) 에서 가져온 burstCapacity, replenishRate, requestedTokens 와 같은 인자값들을 문자열로 변형해서 List로 만듭니다.\n(2)\n(2) 에서는 redisTemplate 을 이용해서 lua script 를 실행시키는데, 이때 Argument 는 (1) 에서 초기화한 List<String> 입니다.\nthis.script 는 RedisRateLimiter 내에 정의된 RedisScript<List<Long>> 타입의 lua script 객체입니다.","lua-스크립트#lua 스크립트":"Lua 스크립트 - 위키 , 나무위키\nRedis - 위키\nlua download - https://www.lua.org/download.html\nlua binary : https://luabinaries.sourceforge.net/download.html\nMac OS 에서는 brew, Linux 에서는 apt-get 등과 같은 패키지 매니저를 통해서 설치 가능합니다. 제 경우에는 개발 PC를 깔끔하게 유지하는것을 선호하기에 온라인 에디터를 사용했고 온라인 에디터에 대해서는 https://replit.com/languages/lua 을 참고해주시기 바랍니다.\nLua 스크립트는 레디스 내의 인터프리터는 Lua 스크립트를 읽을수 있으며 실행 가능합니다. Lua 스크립트를 사용하면, 레디스 머신 내에서 레디스 실행엔진이 Lua 스크립트를 인터프리터로 해석해서 스크립트를 실행합니다.클라이언트인 각각의 개별 서비스에서 레디스의 List,Set 의 데이터를 복사한 후 열어서 접근할 때 레디스 입장에서는 동일한 값이 복제되었을 때에 대해 데이터가 모호해질 수 있습니다.이런 경우에는 Redis 내에 구성한 List, Set 등과 같은 자료구조에 접근하는 주체가 Redis 머신이 되도록 바꿔주면, 데이터의 불일치 현상을 방지할 수 있습니다.Redis 에 Script 를 통해 접근하면 Redis 서버 내에서의 Atomic 연산을 보장해줍니다. 따라서 Rate Limiter, Coupon 발급기 같은 작업 대기열 기반 트래픽 처리를 할 때 유용합니다.Lua 라는 언어는 브라질에서 1993년도애 개발된 프로그래밍 언어인데, C/C++ 프로그램 내부에 포함시키기 쉬우면서 깔끔하고 쉬운 문법의 스크립트 언어입니다. Redis 는 C/C++ 기반으로 작성된 데이터 플랫폼입니다. 그리고 Lua 스크립트를 실행할 수 있도록 Lua 스크립트와 관련된 기능을 지원하고 있습니다.Lua 언어의 설치는 https://www.lua.org/download.html 에서 다운로드 받아서 설치 가능합니다.","request_rate_limiterlua#request_rate_limiter.lua":"만약 우리가 RedisLimiter 를 의존성 주입하지 않는다면 Spring Cloud Gateway 에서 기본으로 제공해주는 request_rate_limiter.lua가 선택되어 사용하게 됩니다.\nrequest_rate_limiter.lua 의 경로는 spring-cloud-gateway-server/src/main/resources/META-INF/scripts/request_rate_limiter.lua 입니다.\nlocal tokens_key = KEYS[1]\r\nlocal timestamp_key = KEYS[2]\r\n--redis.log(redis.LOG_WARNING, \"tokens_key \" .. tokens_key)\r\n\r\nlocal rate = tonumber(ARGV[1])\r\nlocal capacity = tonumber(ARGV[2])\r\nlocal now = tonumber(ARGV[3])\r\nlocal requested = tonumber(ARGV[4])\r\n\r\nlocal fill_time = capacity/rate\r\nlocal ttl = math.floor(fill_time*2)\r\n\r\n--redis.log(redis.LOG_WARNING, \"rate \" .. ARGV[1])\r\n--redis.log(redis.LOG_WARNING, \"capacity \" .. ARGV[2])\r\n--redis.log(redis.LOG_WARNING, \"now \" .. ARGV[3])\r\n--redis.log(redis.LOG_WARNING, \"requested \" .. ARGV[4])\r\n--redis.log(redis.LOG_WARNING, \"filltime \" .. fill_time)\r\n--redis.log(redis.LOG_WARNING, \"ttl \" .. ttl)\r\n\r\nlocal last_tokens = tonumber(redis.call(\"get\", tokens_key))\r\nif last_tokens == nil then\r\n  last_tokens = capacity\r\nend\r\n--redis.log(redis.LOG_WARNING, \"last_tokens \" .. last_tokens)\r\n\r\nlocal last_refreshed = tonumber(redis.call(\"get\", timestamp_key))\r\nif last_refreshed == nil then\r\n  last_refreshed = 0\r\nend\r\n--redis.log(redis.LOG_WARNING, \"last_refreshed \" .. last_refreshed)\r\n\r\nlocal delta = math.max(0, now-last_refreshed)\r\nlocal filled_tokens = math.min(capacity, last_tokens+(delta*rate))\r\nlocal allowed = filled_tokens >= requested\r\nlocal new_tokens = filled_tokens\r\nlocal allowed_num = 0\r\nif allowed then\r\n  new_tokens = filled_tokens - requested\r\n  allowed_num = 1\r\nend\r\n\r\n--redis.log(redis.LOG_WARNING, \"delta \" .. delta)\r\n--redis.log(redis.LOG_WARNING, \"filled_tokens \" .. filled_tokens)\r\n--redis.log(redis.LOG_WARNING, \"allowed_num \" .. allowed_num)\r\n--redis.log(redis.LOG_WARNING, \"new_tokens \" .. new_tokens)\r\n\r\nif ttl > 0 then\r\n  redis.call(\"setex\", tokens_key, ttl, new_tokens)\r\n  redis.call(\"setex\", timestamp_key, ttl, now)\r\nend\r\n\r\n-- return { allowed_num, new_tokens, capacity, filled_tokens, requested, new_tokens }\r\nreturn { allowed_num, new_tokens }\n자바 코드에서는 아래의 인자값을 넘겨줬었습니다.\nreplenishRate\nburstCapacity\nInstant.now().getEpochSecond() : 초 단위로 구분된 Epoch Time\nrequestedTokens\n위의 스크립트에서는 위의 인자값들을 ARGV 라는 배열로 받습니다.위의 코드는 Token Bucket Algorithm 이 구현된 것인데, Token Bucket Algorithm 에 대해서는 문서가 길어지게 되어서 별도의 문서에서 따로 정리하기로 결정했습니다."}},"/rate-limiter/redis-rate-limiter":{"title":"Redis Rate Limiter","data":{}},"/rate-limiter/redis-docker-compose":{"title":"Redis Docker Compose","data":{"redis-docker-compose#Redis docker-compose":"예제로 사용할 Redis 의 docker-compose 파일입니다. 설명은 생략하겠습니다.\nversion: '3.8'\r\nservices:\r\n  redis:\r\n    image: redis:7.0\r\n    command: redis-server --port 6379\r\n    hostname: redis-localhost\r\n    labels:\r\n      - \"name=redis\"\r\n      - \"mode=standalone\"\r\n    ports:\r\n      - 26379:6379\r\n    depends_on: \r\n      - redis-commander\r\n    links:\r\n      - redis-commander\r\n    # networks:\r\n    #   - redis-local\r\n  redis-commander:\r\n    image: rediscommander/redis-commander:latest\r\n    hostname: redis-commander-localhost\r\n    restart: always\r\n    environment:\r\n      - REDIS_HOSTS=redis-localhost\r\n    ports:\r\n      - 38081:8081\r\n    # networks:\r\n    #   - redis-local\r\n# networks:\r\n#   redis-local:\r\n#     driver: bridge"}},"/rate-limiter/what-is-rate-limiter":{"title":"What Is Rate Limiter","data":{"rate-limiter-의-개념#Rate Limiter 의 개념":""}},"/rate-limiter/token-bucket-algorithm":{"title":"Token Bucket Algorithm","data":{"token-bucket-algorithm-lua#Token Bucket Algorithm (Lua)":""}}}