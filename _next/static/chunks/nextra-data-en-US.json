{"/":{"title":"Introduction","data":{"":"Spring Cloud Gateway 이모저모\nRate Limiter\nFilter"}},"/rate-limiter/example-rate-limiter":{"title":"Example Rate Limiter","data":{"ratelimiter-예제#RateLimiter 예제":"이번 문서에서는 RateLimiter 예제를 작성하는 과정을 정리해봅니다. 이 예제에 대한 github 리포지터리는 아래의 링크를 참고해주시기 바랍니다.\ngitub.com/chagchagchag/example-gateway-rate-limiter","foobar-user#foobar-user":"사용자 가입을 위한 서비스를 foobar-user 라는 모듈로 개발중이라고 하겠습니다. foobar-user 모듈의 내용들은 아래와 같습니다.","buildgradlekts#build.gradle.kts":"// ...\r\n\r\nrepositories {\r\n  mavenCentral()\r\n}\r\n\r\nextra[\"springCloudVersion\"] = \"2023.0.1\"\r\n\r\ndependencies {\r\n  implementation(\"org.springframework.boot:spring-boot-starter-data-redis-reactive\")\r\n  implementation(\"org.springframework.boot:spring-boot-starter-web\")\r\n  testImplementation(\"org.springframework.boot:spring-boot-starter-test\")\r\n  testImplementation(\"io.projectreactor:reactor-test\")\r\n}\r\n\r\ndependencyManagement {\r\n  imports {\r\n    mavenBom(\"org.springframework.cloud:spring-cloud-dependencies:${property(\"springCloudVersion\")}\")\r\n  }\r\n}","healthcheckcontrollerjava#HealthcheckController.java":"간단한 HealthcheckController 코드입니다.\npackage io.chagchagchag.example.user.healthcheck;\r\n\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\n@RestController\r\npublic class HealthcheckController {\r\n  @GetMapping(\"/healthcheck/ready\")\r\n  public String getReady(){\r\n    return \"OK\";\r\n  }\r\n}","동작-확인#동작 확인":"curl 명령으로 아래의 명령을 수행해서 Web (8080) 에서 정상적으로 요청 수행이 되는지 테스트해봅니다.\n$ curl localhost:8080/healthcheck/ready\r\nOK","foobar-gateway#foobar-gateway":"위에서 작성한 foobar-user 애플리케이션에 대해 gateway 역할을 수행하는 모듈입니다.","buildgradlekts-1#build.gradle.kts":"// ...\r\n\r\nrepositories {\r\n  mavenCentral()\r\n}\r\n\r\nextra[\"springCloudVersion\"] = \"2023.0.1\"\r\n\r\ndependencies {\r\n  implementation(\"org.springframework.boot:spring-boot-starter-data-redis-reactive\")\r\n  implementation(\"org.springframework.cloud:spring-cloud-starter-gateway\")\r\n  compileOnly(\"org.projectlombok:lombok\")\r\n  annotationProcessor(\"org.projectlombok:lombok\")\r\n  testImplementation(\"org.springframework.boot:spring-boot-starter-test\")\r\n  testImplementation(\"io.projectreactor:reactor-test\")\r\n}\r\n\r\ndependencyManagement {\r\n  imports {\r\n    mavenBom(\"org.springframework.cloud:spring-cloud-dependencies:${property(\"springCloudVersion\")}\")\r\n  }\r\n}\r\n\r\n// ...","applicationyml#application.yml":"yml 파일 내에서 spring.cloud.gateway.routes[0].filters 내에 정의한 RequestRateLimiter 에 대한 args 중 key-resolver 에 대한 값인 \"#{@userIdAsKeyResolver}\" 값은 직접 정의한 Bean 입니다. 뒤에서 설명합니다.\nserver:\r\n  port: 9000\r\n\r\nspring:\r\n  data:\r\n    redis:\r\n      host: localhost\r\n      port: 26379\r\n      database: 0\r\n  cloud:\r\n    gateway:\r\n      routes:\r\n        - id: all\r\n          uri: http://localhost:8080\r\n          predicates:\r\n            - Path=/**\r\n          filters:\r\n            - name: RequestRateLimiter\r\n              args:\r\n                redis-rate-limiter.replenishRate: 20\r\n                redis-rate-limiter.burstCapacity: 100\r\n                redis-rate-limiter.requestedTokens: 3\r\n                key-resolver: \"#{@userIdAsKeyResolver}\"","useridkeyresolver#UserIdKeyResolver":"사용자가 Request Header 에 전달한 USER-ID 라고 하는 헤더 값을 추출하기 위해 ServerWebExchange 내의 request 내의 Header 내에서 USER-ID 에 대한 값을 추출합니다.그리고 값이 정상일 경우 Mono<String> 을 return 하고 정상이 아닐 경우 Mono.error 를 리턴합니다.\npackage io.chagchagchag.example.gateway.resolver;\r\n\r\nimport java.util.Optional;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.cloud.gateway.filter.ratelimit.KeyResolver;\r\nimport org.springframework.stereotype.Component;\r\nimport org.springframework.web.server.ServerWebExchange;\r\nimport reactor.core.publisher.Mono;\r\n\r\n@Component(\"userIdAsKeyResolver\")\r\npublic class UserIdKeyResolver implements KeyResolver {\r\n  private final Logger logger = LoggerFactory.getLogger(UserIdKeyResolver.class);\r\n  @Override\r\n  public Mono<String> resolve(ServerWebExchange exchange) {\r\n    final String userId = exchange.getRequest()\r\n        .getHeaders()\r\n        .getFirst(\"USER-ID\");\r\n\r\n    return Optional.ofNullable(userId)\r\n        .map(Mono::justOrEmpty)\r\n        .orElseGet(() -> {\r\n          exchange.getResponse().setComplete();\r\n          logger.debug(\">>> 'USER-ID' is Empty\");\r\n          return Mono.error(new IllegalArgumentException(\"존재하지 않는 아이디입니다.\"));\r\n        });\r\n  }\r\n}","동작-확인-1#동작 확인":"먼저 foobar-user 를 기동시킵니다.\n그리고 foobar-gateway 를 기동시킵니다.\ncurl 명령으로 아래의 명령을 수행해서 Gateway 에서 정상적으로 동작하는지 확인합니다.\n$ curl -X GET localhost:9000/healthcheck/ready -H \"Content-Type: application/json\" -H \"USER-ID:'A'\"\r\nOK","curl-명령어#curl 명령어":"주로 http 파일을 쓰거나 springdoc 를 사용하는 편이지만, 간단한 테스트는 curl 로만 수행하는게 오히려 더 편할 때가 많습니다. 그래서 막간을 이용해서 curl 명령어를 정리해봅니다.curl 명령어 사용시 자주 사용하는 옵션은 3가지 입니다.\n-d, --data : \"data\" 를 의미합니다.\n-H, --header : \"header\" 를 의미합니다. 리퀘스트 전송시 헤더에 특정 값을 전달해야 할 경우 -H 를 지정해줍니다.\n-X, --request : 사용할 요청 메서드(GET, POST, PUT 등)를 명시해주기 위해 사용하는 옵션입니다.\n예를 들어 curl 명령어로 GET 요청을 하는데, 헤더에 USER-ID : A 를 전달해주려고 한다면 아래의 명령을 수행하면 됩니다.\n$ curl -X GET localhost:8080/healthcheck/ready -H \"Content-Type: application/json\" -d \"{\"USER-ID\": \"A\"}\"\r\nOK"}},"/rate-limiter/example-custom-rate-limiter":{"title":"Example Custom Rate Limiter","data":{"custom-rate-limiter-예제#Custom Rate Limiter 예제":"이번 문서에서는 Custom 한 RateLimiter 예제를 작성하는 과정을 정리해봅니다. 이 예제에 대한 github 리포지터리는 아래의 링크를 참고해주시기 바랍니다.\ngitub.com/chagchagchag/example-gateway-rate-limiter\n기본으로 제공되는 Rate Limiter 는 Rate Limit 을 넘어갔을 때 응답이 내부적으로 정해진 방식으로만 응답될 수 밖에 없습니다. 하지만, 응답코드, 응답본문, 응답 메시지를 직접 정한 방식으로 내보내려 할 경우 Custom Rate Limiter 를 사용하게 됩니다.아래에서부터는 Custom Rate Limiter 에 대한 예제입니다.","foobar-user#foobar-user":"사용자 가입을 위한 서비스를 foobar-user 라는 모듈로 개발중이라고 하겠습니다. foobar-user 모듈의 내용들은 아래와 같습니다.","buildgradlekts#build.gradle.kts":"// ...\r\n\r\nrepositories {\r\n  mavenCentral()\r\n}\r\n\r\nextra[\"springCloudVersion\"] = \"2023.0.1\"\r\n\r\ndependencies {\r\n  implementation(\"org.springframework.boot:spring-boot-starter-data-redis-reactive\")\r\n  implementation(\"org.springframework.boot:spring-boot-starter-web\")\r\n  testImplementation(\"org.springframework.boot:spring-boot-starter-test\")\r\n  testImplementation(\"io.projectreactor:reactor-test\")\r\n}\r\n\r\ndependencyManagement {\r\n  imports {\r\n    mavenBom(\"org.springframework.cloud:spring-cloud-dependencies:${property(\"springCloudVersion\")}\")\r\n  }\r\n}","healthcheckcontrollerjava#HealthcheckController.java":"간단한 HealthcheckController 코드입니다.\npackage io.chagchagchag.example.user.healthcheck;\r\n\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\n@RestController\r\npublic class HealthcheckController {\r\n  @GetMapping(\"/healthcheck/ready\")\r\n  public String getReady(){\r\n    return \"OK\";\r\n  }\r\n}","동작-확인#동작 확인":"curl 명령으로 아래의 명령을 수행해서 Web (8080) 에서 정상적으로 요청 수행이 되는지 테스트해봅니다.\n$ curl localhost:8080/healthcheck/ready\r\nOK","foobar-gateway#foobar-gateway":"위에서 작성한 foobar-user 애플리케이션에 대해 gateway 역할을 수행하는 모듈입니다.","buildgradlekts-1#build.gradle.kts":"// ...\r\n\r\nrepositories {\r\n  mavenCentral()\r\n}\r\n\r\nextra[\"springCloudVersion\"] = \"2023.0.1\"\r\n\r\ndependencies {\r\n  implementation(\"org.springframework.boot:spring-boot-starter-data-redis-reactive\")\r\n  implementation(\"org.springframework.cloud:spring-cloud-starter-gateway\")\r\n  compileOnly(\"org.projectlombok:lombok\")\r\n  annotationProcessor(\"org.projectlombok:lombok\")\r\n  testImplementation(\"org.springframework.boot:spring-boot-starter-test\")\r\n  testImplementation(\"io.projectreactor:reactor-test\")\r\n}\r\n\r\ndependencyManagement {\r\n  imports {\r\n    mavenBom(\"org.springframework.cloud:spring-cloud-dependencies:${property(\"springCloudVersion\")}\")\r\n  }\r\n}\r\n\r\n// ...","applicationyml#application.yml":"yml 파일 내에서 spring.cloud.gateway.routes[0].filters 내에 정의한 RequestRateLimiter 에 대한 args 중 key-resolver 에 대한 값인 \"#{@userIdAsKeyResolver}\" 값은 직접 정의한 Bean 입니다. 뒤에서 설명합니다.\nserver:\r\n  port: 9000\r\n\r\nspring:\r\n  data:\r\n    redis:\r\n      host: localhost\r\n      port: 26379\r\n      database: 0\r\n  cloud:\r\n    gateway:\r\n      routes:\r\n        - id: all\r\n          uri: http://localhost:8080\r\n          predicates:\r\n            - Path=/**\r\n          filters:\r\n            - name: CustomRedisRateLimitFilter\r\n              args:\r\n                redis-rate-limiter.replenishRate: 20\r\n                redis-rate-limiter.burstCapacity: 100\r\n                redis-rate-limiter.requestedTokens: 3\r\n                key-resolver: \"#{@userIdAsKeyResolver}\"","useridkeyresolver#UserIdKeyResolver":"사용자가 Request Header 에 전달한 USER-ID 라고 하는 헤더 값을 추출하기 위해 ServerWebExchange 내의 request 내의 Header 내에서 USER-ID 에 대한 값을 추출합니다.그리고 값이 정상일 경우 Mono<String> 을 return 하고 정상이 아닐 경우 Mono.error 를 리턴합니다.\npackage io.chagchagchag.example.gateway.resolver;\r\n\r\nimport java.util.Optional;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.cloud.gateway.filter.ratelimit.KeyResolver;\r\nimport org.springframework.stereotype.Component;\r\nimport org.springframework.web.server.ServerWebExchange;\r\nimport reactor.core.publisher.Mono;\r\n\r\n@Component(\"userIdAsKeyResolver\")\r\npublic class UserIdKeyResolver implements KeyResolver {\r\n  private final Logger logger = LoggerFactory.getLogger(UserIdKeyResolver.class);\r\n  @Override\r\n  public Mono<String> resolve(ServerWebExchange exchange) {\r\n    final String userId = exchange.getRequest()\r\n        .getHeaders()\r\n        .getFirst(\"USER-ID\");\r\n\r\n    return Optional.ofNullable(userId)\r\n        .map(Mono::justOrEmpty)\r\n        .orElseGet(() -> {\r\n          exchange.getResponse().setComplete();\r\n          logger.debug(\">>> 'USER-ID' is Empty\");\r\n          return Mono.error(new IllegalArgumentException(\"존재하지 않는 아이디입니다.\"));\r\n        });\r\n  }\r\n}","customredisratelimitfilter#CustomRedisRateLimitFilter":"AbstractGatewayFilterFactory<T> 를 상속한 별도의 Filter 를 생성했고 이 것의 역할은 Redis 를 이용해 Custom 한 Rate Limiter 역할을 수행하는 것입니다.\npackage io.chagchagchag.example.gateway.filter;\r\n\r\nimport io.chagchagchag.example.gateway.resolver.UserIdKeyResolver;\r\nimport java.nio.charset.StandardCharsets;\r\nimport lombok.Getter;\r\nimport lombok.Setter;\r\nimport org.springframework.cloud.gateway.filter.GatewayFilter;\r\nimport org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;\r\nimport org.springframework.cloud.gateway.filter.ratelimit.KeyResolver;\r\nimport org.springframework.cloud.gateway.filter.ratelimit.RateLimiter;\r\nimport org.springframework.cloud.gateway.filter.ratelimit.RedisRateLimiter;\r\nimport org.springframework.cloud.gateway.support.HasRouteId;\r\nimport org.springframework.http.HttpStatus;\r\nimport org.springframework.http.MediaType;\r\nimport org.springframework.http.server.reactive.ServerHttpResponse;\r\nimport org.springframework.stereotype.Component;\r\nimport reactor.core.publisher.Mono;\r\n\r\n@Component\r\npublic class CustomRedisRateLimitFilter extends AbstractGatewayFilterFactory<CustomRedisRateLimitFilter.Config> {\r\n  private final RateLimiter<RedisRateLimiter.Config> rateLimiter;\r\n  private final UserIdKeyResolver userIdKeyResolver;\r\n\r\n  public CustomRedisRateLimitFilter(\r\n      RateLimiter<RedisRateLimiter.Config> rateLimiter,\r\n      UserIdKeyResolver userIdKeyResolver\r\n  ) {\r\n    super(Config.class);\r\n    this.rateLimiter = rateLimiter;\r\n    this.userIdKeyResolver = userIdKeyResolver;\r\n  }\r\n\r\n  @Override\r\n  public GatewayFilter apply(Config config) {\r\n    return (exchange, chain) -> {\r\n      var response = exchange.getResponse();\r\n      var keyResolver = config.keyResolver;\r\n      var routeId = config.routeId;\r\n\r\n      return keyResolver.resolve(exchange)\r\n          .flatMap(key -> this.rateLimiter.isAllowed(routeId, key))\r\n          .flatMap(rateLimitResponse -> {\r\n            boolean allowed = rateLimitResponse.isAllowed();\r\n            if(allowed) return chain.filter(exchange);\r\n            else return responseTooManyRequest(response);\r\n          });\r\n    };\r\n  }\r\n\r\n  public Mono<Void> responseTooManyRequest(ServerHttpResponse response){\r\n    response.setStatusCode(HttpStatus.TOO_MANY_REQUESTS);\r\n    response.getHeaders().setContentType(MediaType.APPLICATION_JSON);\r\n    return response.writeWith(\r\n        Mono.just(\r\n            response.bufferFactory().wrap(\r\n                \"\"\"\r\n                |\"success\": false,\r\n                |\"message\": \"Too Many Requests\"\r\n                \"\"\".trim().getBytes(StandardCharsets.UTF_8)\r\n            )\r\n        )\r\n    );\r\n  }\r\n\r\n  @Getter @Setter\r\n  static class Config implements HasRouteId {\r\n    private KeyResolver keyResolver;\r\n    private String routeId;\r\n\r\n    public Config(){}\r\n\r\n    public Config(KeyResolver keyResolver){\r\n      this.keyResolver = keyResolver;\r\n    }\r\n\r\n    public Config(\r\n        KeyResolver keyResolver,\r\n        String routeId\r\n    ){\r\n      this.keyResolver = keyResolver;\r\n      this.routeId = routeId;\r\n    }\r\n\r\n    @Override\r\n    public void setRouteId(String routeId) {\r\n      this.routeId = routeId;\r\n    }\r\n\r\n    @Override\r\n    public String getRouteId() {\r\n      return routeId;\r\n    }\r\n  }\r\n}","동작-확인-1#동작 확인":"먼저 foobar-user 를 기동시킵니다.\n그리고 foobar-gateway 를 기동시킵니다.\ncurl 명령으로 아래의 명령을 수행해서 Gateway 에서 정상적으로 동작하는지 확인합니다.\n$ curl -X GET localhost:9000/healthcheck/ready -H \"Content-Type: application/json\" -H \"USER-ID:'A'\"\r\nOK","curl-명령어#curl 명령어":"주로 http 파일을 쓰거나 springdoc 를 사용하는 편이지만, 간단한 테스트는 curl 로만 수행하는게 오히려 더 편할 때가 많습니다. 그래서 막간을 이용해서 curl 명령어를 정리해봅니다.curl 명령어 사용시 자주 사용하는 옵션은 3가지 입니다.\n-d, --data : \"data\" 를 의미합니다.\n-H, --header : \"header\" 를 의미합니다. 리퀘스트 전송시 헤더에 특정 값을 전달해야 할 경우 -H 를 지정해줍니다.\n-X, --request : 사용할 요청 메서드(GET, POST, PUT 등)를 명시해주기 위해 사용하는 옵션입니다.\n예를 들어 curl 명령어로 GET 요청을 하는데, 헤더에 USER-ID : A 를 전달해주려고 한다면 아래의 명령을 수행하면 됩니다.\n$ curl -X GET localhost:8080/healthcheck/ready -H \"Content-Type: application/json\" -d \"{\"USER-ID\": \"A\"}\"\r\nOK"}},"/rate-limiter":{"title":"Rate Limiter","data":{"rate-limiter#Rate Limiter":"","참고#참고":"spring.io/projects/spring-cloud-gateway\nReference Doc","rate-limiter-1#Rate Limiter":"Spring Cloud Gateway 의 Official Page 에서는 주요 Feature 들에 대해서 아래의 내용들을 이야기하고 있습니다.Spring Cloud Gateway features:\nBuilt on Spring Framework and Spring Boot\nAble to match routes on any request attribute.\nPredicates and filters are specific to routes.\nCircuit Breaker integration.\nSpring Cloud DiscoveryClient integration\nEasy to write Predicates and Filters\nRequest Rate Limiting\nPath Rewriting\n이번 카테고리에서는 위의 요소들 중 끝에서 두 번째 요소인 Request Rate Limiting 에 대해서 정리합니다."}},"/filter":{"title":"Filter","data":{}},"/rate-limiter/what-is-rate-limiter":{"title":"What Is Rate Limiter","data":{"redis-docker-compose#Redis docker-compose":"예제로 사용할 Redis 의 docker-compose 파일입니다. 설명은 생략하겠습니다.\nversion: '3.8'\r\nservices:\r\n  redis:\r\n    image: redis:7.0\r\n    command: redis-server --port 6379\r\n    hostname: redis-localhost\r\n    labels:\r\n      - \"name=redis\"\r\n      - \"mode=standalone\"\r\n    ports:\r\n      - 26379:6379\r\n    depends_on: \r\n      - redis-commander\r\n    links:\r\n      - redis-commander\r\n    # networks:\r\n    #   - redis-local\r\n  redis-commander:\r\n    image: rediscommander/redis-commander:latest\r\n    hostname: redis-commander-localhost\r\n    restart: always\r\n    environment:\r\n      - REDIS_HOSTS=redis-localhost\r\n    ports:\r\n      - 38081:8081\r\n    # networks:\r\n    #   - redis-local\r\n# networks:\r\n#   redis-local:\r\n#     driver: bridge"}},"/rate-limiter/inside-redis-rate-limiter":{"title":"Inside Redis Rate Limiter","data":{"redisratelimiter-의-내부-동작#RedisRateLimiter 의 내부 동작":""}},"/rate-limiter/redis-rate-limiter":{"title":"Redis Rate Limiter","data":{}},"/rate-limiter/redis-docker-compose":{"title":"Redis Docker Compose","data":{}}}