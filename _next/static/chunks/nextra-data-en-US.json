{"/rate-limiter":{"title":"Rate Limiter","data":{"rate-limiter#Rate Limiter":"","참고#참고":"spring.io/projects/spring-cloud-gateway\nReference Doc","rate-limiter-1#Rate Limiter":"Spring Cloud Gateway 의 Official Page 에서는 주요 Feature 들에 대해서 아래의 내용들을 이야기하고 있습니다.Spring Cloud Gateway features:\nBuilt on Spring Framework and Spring Boot\nAble to match routes on any request attribute.\nPredicates and filters are specific to routes.\nCircuit Breaker integration.\nSpring Cloud DiscoveryClient integration\nEasy to write Predicates and Filters\nRequest Rate Limiting\nPath Rewriting\n이번 카테고리에서는 위의 요소들 중 끝에서 두 번째 요소인 Request Rate Limiting 에 대해서 정리합니다."}},"/rate-limiter/example-custom-rate-limiter":{"title":"Example Custom Rate Limiter","data":{"custom-rate-limiter-예제#Custom Rate Limiter 예제":"이번 문서에서는 Custom 한 RateLimiter 예제를 작성하는 과정을 정리해봅니다. 이 예제에 대한 github 리포지터리는 아래의 링크를 참고해주시기 바랍니다.\ngitub.com/chagchagchag/example-gateway-rate-limiter\n기본으로 제공되는 Rate Limiter 는 Rate Limit 을 넘어갔을 때 응답이 내부적으로 정해진 방식으로만 응답될 수 밖에 없습니다. 하지만, 응답코드, 응답본문, 응답 메시지를 직접 정한 방식으로 내보내려 할 경우 Custom Rate Limiter 를 사용하게 됩니다.오늘 문서는 Custom Rate Limiter 를 작성하는 과정과 End to End 테스트를 해본 과정을 정리합니다.","rate-limit-token-bucket-algorithm#Rate Limit, Token Bucket Algorithm":"Spring Cloud Gateway 는 Router 기능, Rate Limit 을 모두 제공한다는 점에서 꽤 유용하고 다용도의 기능을 제공하는 것 같습니다. Spring Cloud Gateway 에서 제공하는 RateLimiter 의 기본 Rate Limit 정책은 Token Bucket Algorithm 입니다. Token Bucket Algorithm 에 대해서는 아래의 자료에 자세하게 설명되어 있습니다.\nRate limiting using the Token Bucket algorithm\nBucket4j - Token bucket 알고리즘을 이용한 Rate limit 라이브러리를 알아보자!!\n만약 Rate Limit 을 더 효율적으로 하고 싶을 경우 참고해서 튜닝이 이뤄진 Rate Limit 서비스를 만들 수 있을 것 같아서 추가해둔 자료입니다.\nRate Limiter 를 분산환경에서 적용시 일반적으로는 Redis 와 같은 data store 를 이용하게 됩니다. 이 경우 고민해야 할 점으로는 Race Condition 이 발생할 수 있다는 점 역시 어느 정도는 고민에 넣어두어야 할 것 같습니다. 따라서 이 경우 TTL 을 따로 지정해줘서 특정 키값의 만료를 지정한다는가 하는 설정을 따로 해두는 것을 권장합니다.RFC6585 에서는 Rate Limit 적용 시 한계치에 도달했을 때 응답으로 \"429 Too Many Request\" 를 응답하도록 권고하고 있습니다. 그리고 아래의 정보들도 부가적으로 Header 에 같이 전달해주면 좋습니다.\nRateLimit-Used : 기준 시간 단위 API 호출 수\nRateLimit-Limit : 허용되는 요청의 최대 수\nRateLimit-Remaining : 남은 요청 수\nRateLimit-Reset : 요청 최대값이 재설정 될 때 까지의 시간\n참고 : Naver Works Developers > 참고사항 > Rate Limits","foobar-user#foobar-user":"사용자 가입을 위한 서비스를 foobar-user 라는 모듈로 개발중이라고 하겠습니다. foobar-user 모듈의 내용들은 아래와 같습니다.","buildgradlekts#build.gradle.kts":"// ...\r\n\r\nrepositories {\r\n  mavenCentral()\r\n}\r\n\r\nextra[\"springCloudVersion\"] = \"2023.0.1\"\r\n\r\ndependencies {\r\n  implementation(\"org.springframework.boot:spring-boot-starter-data-redis-reactive\")\r\n  implementation(\"org.springframework.boot:spring-boot-starter-web\")\r\n  testImplementation(\"org.springframework.boot:spring-boot-starter-test\")\r\n  testImplementation(\"io.projectreactor:reactor-test\")\r\n}\r\n\r\ndependencyManagement {\r\n  imports {\r\n    mavenBom(\"org.springframework.cloud:spring-cloud-dependencies:${property(\"springCloudVersion\")}\")\r\n  }\r\n}","healthcheckcontrollerjava#HealthcheckController.java":"간단한 HealthcheckController 코드입니다.\npackage io.chagchagchag.example.user.healthcheck;\r\n\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\n@RestController\r\npublic class HealthcheckController {\r\n  @GetMapping(\"/healthcheck/ready\")\r\n  public String getReady(){\r\n    return \"OK\";\r\n  }\r\n}","동작-확인#동작 확인":"curl 명령으로 아래의 명령을 수행해서 Web (8080) 에서 정상적으로 요청 수행이 되는지 테스트해봅니다.\n$ curl localhost:8080/healthcheck/ready\r\nOK","foobar-gateway#foobar-gateway":"위에서 작성한 foobar-user 애플리케이션에 대해 gateway 역할을 수행하는 모듈입니다.","buildgradlekts-1#build.gradle.kts":"// ...\r\n\r\nrepositories {\r\n  mavenCentral()\r\n}\r\n\r\nextra[\"springCloudVersion\"] = \"2023.0.1\"\r\n\r\ndependencies {\r\n  implementation(\"org.springframework.boot:spring-boot-starter-data-redis-reactive\")\r\n  implementation(\"org.springframework.cloud:spring-cloud-starter-gateway\")\r\n  compileOnly(\"org.projectlombok:lombok\")\r\n  annotationProcessor(\"org.projectlombok:lombok\")\r\n  testImplementation(\"org.springframework.boot:spring-boot-starter-test\")\r\n  testImplementation(\"io.projectreactor:reactor-test\")\r\n}\r\n\r\ndependencyManagement {\r\n  imports {\r\n    mavenBom(\"org.springframework.cloud:spring-cloud-dependencies:${property(\"springCloudVersion\")}\")\r\n  }\r\n}\r\n\r\n// ...","applicationyml#application.yml":"yml 파일 내에서 spring.cloud.gateway.routes[0].filters 내에 정의한 RequestRateLimiter 에 대한 args 중 key-resolver 에 대한 값인 \"#{@userIdAsKeyResolver}\" 값은 직접 정의한 Bean 입니다. 뒤에서 설명합니다.\nserver:\r\n  port: 9000\r\n\r\nspring:\r\n  data:\r\n    redis:\r\n      host: localhost\r\n      port: 26379\r\n      database: 0\r\n  cloud:\r\n    gateway:\r\n      routes:\r\n        - id: all\r\n          uri: http://localhost:8080\r\n          predicates:\r\n            - Path=/**\r\n          filters:\r\n            - name: CustomRedisRateLimitFilter\r\n              args:\r\n                redis-rate-limiter.replenishRate: 20\r\n                redis-rate-limiter.burstCapacity: 100\r\n                redis-rate-limiter.requestedTokens: 3\r\n                key-resolver: \"#{@userIdAsKeyResolver}\"\nreplenishRate : 초당 버킷 회복 량을 의미합니다. 위에서는 100 을 지정했는데 1초 내에 어떤 요청이 90회 발생하면, 100을 채워주므로 1초 되에 다시 버킷이 100 으로 회복됩니다.\nburstCapacitiy : 버킷에 담을 수 있는 최대 양을 의미합니다.\nrequestedTokens : 요청 시에 소모할 토큰의 갯수를 의미합니다. 3으로 설정했으므로 요청 하나당 3 의 토큰이 소모됩니다.\nkey-resolver : \"#{@userIdKeyResolver}\" 로 지정해줬는데, Java Config 로 미리 정의해둔 \"userIdKeyResolver\" 라는 이름의 Bean 을 의미하는 SPEL 표현식입니다.","useridkeyresolver#UserIdKeyResolver":"사용자가 Request Header 에 전달한 USER-ID 라고 하는 헤더 값을 추출하기 위해 ServerWebExchange 내의 request 내의 Header 내에서 USER-ID 에 대한 값을 추출합니다.그리고 값이 정상일 경우 Mono<String> 을 return 하고 정상이 아닐 경우 Mono.error 를 리턴합니다.\npackage io.chagchagchag.example.gateway.resolver;\r\n\r\nimport java.util.Optional;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.cloud.gateway.filter.ratelimit.KeyResolver;\r\nimport org.springframework.stereotype.Component;\r\nimport org.springframework.web.server.ServerWebExchange;\r\nimport reactor.core.publisher.Mono;\r\n\r\n@Component(\"userIdAsKeyResolver\")\r\npublic class UserIdKeyResolver implements KeyResolver {\r\n  private final Logger logger = LoggerFactory.getLogger(UserIdKeyResolver.class);\r\n  @Override\r\n  public Mono<String> resolve(ServerWebExchange exchange) {\r\n    final String userId = exchange.getRequest()\r\n        .getHeaders()\r\n        .getFirst(\"USER-ID\");\r\n\r\n    return Optional.ofNullable(userId)\r\n        .map(Mono::justOrEmpty)\r\n        .orElseGet(() -> {\r\n          exchange.getResponse().setComplete();\r\n          logger.debug(\">>> 'USER-ID' is Empty\");\r\n          return Mono.error(new IllegalArgumentException(\"존재하지 않는 아이디입니다.\"));\r\n        });\r\n  }\r\n}","customredisratelimitfilter#CustomRedisRateLimitFilter":"AbstractGatewayFilterFactory<T> 를 상속한 별도의 Filter 를 생성했고 이 것의 역할은 Redis 를 이용해 Custom 한 Rate Limiter 역할을 수행하는 것입니다.\npackage io.chagchagchag.example.gateway.filter;\r\n\r\nimport io.chagchagchag.example.gateway.resolver.UserIdKeyResolver;\r\nimport java.nio.charset.StandardCharsets;\r\nimport lombok.Getter;\r\nimport lombok.Setter;\r\nimport org.springframework.cloud.gateway.filter.GatewayFilter;\r\nimport org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;\r\nimport org.springframework.cloud.gateway.filter.ratelimit.KeyResolver;\r\nimport org.springframework.cloud.gateway.filter.ratelimit.RateLimiter;\r\nimport org.springframework.cloud.gateway.filter.ratelimit.RedisRateLimiter;\r\nimport org.springframework.cloud.gateway.support.HasRouteId;\r\nimport org.springframework.http.HttpStatus;\r\nimport org.springframework.http.MediaType;\r\nimport org.springframework.http.server.reactive.ServerHttpResponse;\r\nimport org.springframework.stereotype.Component;\r\nimport reactor.core.publisher.Mono;\r\n\r\n@Component\r\npublic class CustomRedisRateLimitFilter extends AbstractGatewayFilterFactory<CustomRedisRateLimitFilter.Config> {\r\n  private final RateLimiter<RedisRateLimiter.Config> rateLimiter;\r\n  private final UserIdKeyResolver userIdKeyResolver;\r\n\r\n  public CustomRedisRateLimitFilter(\r\n      RateLimiter<RedisRateLimiter.Config> rateLimiter,\r\n      UserIdKeyResolver userIdKeyResolver\r\n  ) {\r\n    super(Config.class);\r\n    this.rateLimiter = rateLimiter;\r\n    this.userIdKeyResolver = userIdKeyResolver;\r\n  }\r\n\r\n  @Override\r\n  public GatewayFilter apply(Config config) {\r\n    return (exchange, chain) -> {\r\n      var response = exchange.getResponse();\r\n      var keyResolver = config.keyResolver;\r\n      var routeId = config.routeId;\r\n\r\n      return keyResolver.resolve(exchange)\r\n          .flatMap(key -> this.rateLimiter.isAllowed(routeId, key))\r\n          .flatMap(rateLimitResponse -> {\r\n            boolean allowed = rateLimitResponse.isAllowed();\r\n            if(allowed) return chain.filter(exchange);\r\n            else return responseTooManyRequest(response);\r\n          });\r\n    };\r\n  }\r\n\r\n  public Mono<Void> responseTooManyRequest(ServerHttpResponse response){\r\n    response.setStatusCode(HttpStatus.TOO_MANY_REQUESTS);\r\n    response.getHeaders().setContentType(MediaType.APPLICATION_JSON);\r\n    return response.writeWith(\r\n        Mono.just(\r\n            response.bufferFactory().wrap(\r\n                \"\"\"\r\n                |\"success\": false,\r\n                |\"message\": \"Too Many Requests\"\r\n                \"\"\".trim().getBytes(StandardCharsets.UTF_8)\r\n            )\r\n        )\r\n    );\r\n  }\r\n\r\n  @Getter @Setter\r\n  static class Config implements HasRouteId {\r\n    private KeyResolver keyResolver;\r\n    private String routeId;\r\n\r\n    public Config(){}\r\n\r\n    public Config(KeyResolver keyResolver){\r\n      this.keyResolver = keyResolver;\r\n    }\r\n\r\n    public Config(\r\n        KeyResolver keyResolver,\r\n        String routeId\r\n    ){\r\n      this.keyResolver = keyResolver;\r\n      this.routeId = routeId;\r\n    }\r\n\r\n    @Override\r\n    public void setRouteId(String routeId) {\r\n      this.routeId = routeId;\r\n    }\r\n\r\n    @Override\r\n    public String getRouteId() {\r\n      return routeId;\r\n    }\r\n  }\r\n}","동작-확인-1#동작 확인":"먼저 foobar-user 를 기동시킵니다.\n그리고 foobar-gateway 를 기동시킵니다.\ncurl 명령으로 아래의 명령을 수행해서 Gateway 에서 정상적으로 동작하는지 확인합니다.\n$ curl -X GET localhost:9000/healthcheck/ready -H \"Content-Type: application/json\" -H \"USER-ID:'A'\"\r\nOK","curl-명령어#curl 명령어":"주로 http 파일을 쓰거나 springdoc 를 사용하는 편이지만, 간단한 테스트는 curl 로만 수행하는게 오히려 더 편할 때가 많습니다. 그래서 막간을 이용해서 curl 명령어를 정리해봅니다.curl 명령어 사용시 자주 사용하는 옵션은 3가지 입니다.\n-d, --data : \"data\" 를 의미합니다.\n-H, --header : \"header\" 를 의미합니다. 리퀘스트 전송시 헤더에 특정 값을 전달해야 할 경우 -H 를 지정해줍니다.\n-X, --request : 사용할 요청 메서드(GET, POST, PUT 등)를 명시해주기 위해 사용하는 옵션입니다.\n예를 들어 curl 명령어로 GET 요청을 하는데, 헤더에 USER-ID : A 를 전달해주려고 한다면 아래의 명령을 수행하면 됩니다.\n$ curl -X GET localhost:8080/healthcheck/ready -H \"Content-Type: application/json\" -d \"{\"USER-ID\": \"A\"}\"\r\nOK","e2e-테스트#e2e 테스트":"먼저 테스트를 위해 application.yml 내의 설정을 아래와 같이 바꿔줍니다. 그리고 Gateway Application 을 재기동해줍니다. Filter 를 CustomRedisRateLimitFilter 을 사용하도록 지정해줬습니다.\nserver:\r\n  port: 9000\r\n\r\nspring:\r\n  data:\r\n    redis:\r\n      host: localhost\r\n      port: 26379\r\n      database: 0\r\n  cloud:\r\n    gateway:\r\n      routes:\r\n        - id: all\r\n          uri: http://localhost:8080\r\n          predicates:\r\n            - Path=/**\r\n          filters:\r\n#            - name: RequestRateLimiter\r\n            - name: CustomRedisRateLimitFilter\r\n              args:\r\n                redis-rate-limiter.replenishRate: 1\r\n                redis-rate-limiter.burstCapacity: 10\r\n                redis-rate-limiter.requestedTokens: 2\r\n                key-resolver: \"#{@userIdAsKeyResolver}\"\nburstCapacity 를 10초로 했고, requestedTokens 는 2로 설정해서 한 번의 요청에 토큰이 2개 소모되게끔 해주었습니다. 초당 버킷 회복량인 replenishRate 는 1 로 지정해서 버킷이 1초에 1정도가 회복되게끔 해줬습니다.curl 요청 테스트 스크립트 작성curl 요청을 0.5 초에 한번씩 30번 수행하는 스크립트입니다. replenishRate 는 1이므로 1초마다 1정도가 버킷에서 회복되고 requestesTokens 는 2 이므로 0.5초에 2번의 요청이 발생하면 4 개의 Token 이 1초에 한번씩 소모됩니다. 따라서 10 - 4 = 6 이 되고, 1초에 한번씩 버킷 사이즈는 6이 되었다가 다시 10으로 회복되는 방식입니다.curl 스크립트는 아래와 같습니다.\nfor((i=0; i<30; i++)); do\r\n  sleep .5\r\n  curl -X GET localhost:9000/healthcheck/ready -H \"Content-Type: application/json\" -H \"USER-ID:'A'\";\r\ndone\n실행결과실행결과를 보면 의도한대로 15개의 요청이 성공했으며, 이외의 요청들은 모두 Too Many Requests 라는 응답을 받았음을 확인 가능합니다.\n$ source curl-request-finite.sh \r\nOKOKOKOKOKOKOK|\"success\": false,\r\n|\"message\": \"Too Many Requests\"OK|\"success\": false,\r\n|\"message\": \"Too Many Requests\"|\"success\": false,\r\n|\"message\": \"Too Many Requests\"OK|\"success\": false,\r\n|\"message\": \"Too Many Requests\"|\"success\": false,\r\n|\"message\": \"Too Many Requests\"OK|\"success\": false,\r\n|\"message\": \"Too Many Requests\"OK|\"success\": false,\r\n|\"message\": \"Too Many Requests\"|\"success\": false,\r\n|\"message\": \"Too Many Requests\"OK|\"success\": false,\r\n|\"message\": \"Too Many Requests\"|\"success\": false,\r\n|\"message\": \"Too Many Requests\"OK|\"success\": false,\r\n|\"message\": \"Too Many Requests\"|\"success\": false,\r\n|\"message\": \"Too Many Requests\"OK|\"success\": false,\r\n|\"message\": \"Too Many Requests\"|\"success\": false,\r\n|\"message\": \"Too Many Requests\"OK|\"success\": false,\r\n|\"message\": \"Too Many Requests\"","성능부하테스트#성능/부하테스트":"정리 예정!!"}},"/":{"title":"Introduction","data":{"":"Spring Cloud Gateway 이모저모\nRate Limiter\nFilter"}},"/rate-limiter/example-rate-limiter":{"title":"Example Rate Limiter","data":{"ratelimiter-예제#RateLimiter 예제":"이번 문서에서는 RateLimiter 예제를 작성하는 과정을 정리해봅니다. 이 예제에 대한 github 리포지터리는 아래의 링크를 참고해주시기 바랍니다.\ngitub.com/chagchagchag/example-gateway-rate-limiter","rate-limit-token-bucket-algorithm#Rate Limit, Token Bucket Algorithm":"Spring Cloud Gateway 는 Router 기능, Rate Limit 을 모두 제공한다는 점에서 꽤 유용하고 다용도의 기능을 제공하는 것 같습니다. Spring Cloud Gateway 에서 제공하는 RateLimiter 의 기본 Rate Limit 정책은 Token Bucket Algorithm 입니다. Token Bucket Algorithm 에 대해서는 아래의 자료에 자세하게 설명되어 있습니다.\nRate limiting using the Token Bucket algorithm\nBucket4j - Token bucket 알고리즘을 이용한 Rate limit 라이브러리를 알아보자!!\n만약 Rate Limit 을 더 효율적으로 하고 싶을 경우 참고해서 튜닝이 이뤄진 Rate Limit 서비스를 만들 수 있을 것 같아서 추가해둔 자료입니다.\nRate Limiter 를 분산환경에서 적용시 일반적으로는 Redis 와 같은 data store 를 이용하게 됩니다. 이 경우 고민해야 할 점으로는 Race Condition 이 발생할 수 있다는 점 역시 어느 정도는 고민에 넣어두어야 할 것 같습니다. 따라서 이 경우 TTL 을 따로 지정해줘서 특정 키값의 만료를 지정한다는가 하는 설정을 따로 해두는 것을 권장합니다.RFC6585 에서는 Rate Limit 적용 시 한계치에 도달했을 때 응답으로 \"429 Too Many Request\" 를 응답하도록 권고하고 있습니다. 그리고 아래의 정보들도 부가적으로 Header 에 같이 전달해주면 좋습니다.\nRateLimit-Used : 기준 시간 단위 API 호출 수\nRateLimit-Limit : 허용되는 요청의 최대 수\nRateLimit-Remaining : 남은 요청 수\nRateLimit-Reset : 요청 최대값이 재설정 될 때 까지의 시간\n참고 : Naver Works Developers > 참고사항 > Rate Limits","foobar-user#foobar-user":"사용자 가입을 위한 서비스를 foobar-user 라는 모듈로 개발중이라고 하겠습니다. foobar-user 모듈의 내용들은 아래와 같습니다.","buildgradlekts#build.gradle.kts":"// ...\r\n\r\nrepositories {\r\n  mavenCentral()\r\n}\r\n\r\nextra[\"springCloudVersion\"] = \"2023.0.1\"\r\n\r\ndependencies {\r\n  implementation(\"org.springframework.boot:spring-boot-starter-data-redis-reactive\")\r\n  implementation(\"org.springframework.boot:spring-boot-starter-web\")\r\n  testImplementation(\"org.springframework.boot:spring-boot-starter-test\")\r\n  testImplementation(\"io.projectreactor:reactor-test\")\r\n}\r\n\r\ndependencyManagement {\r\n  imports {\r\n    mavenBom(\"org.springframework.cloud:spring-cloud-dependencies:${property(\"springCloudVersion\")}\")\r\n  }\r\n}","healthcheckcontrollerjava#HealthcheckController.java":"간단한 HealthcheckController 코드입니다.\npackage io.chagchagchag.example.user.healthcheck;\r\n\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\n@RestController\r\npublic class HealthcheckController {\r\n  @GetMapping(\"/healthcheck/ready\")\r\n  public String getReady(){\r\n    return \"OK\";\r\n  }\r\n}","동작-확인#동작 확인":"curl 명령으로 아래의 명령을 수행해서 Web (8080) 에서 정상적으로 요청 수행이 되는지 테스트해봅니다.\n$ curl localhost:8080/healthcheck/ready\r\nOK","foobar-gateway#foobar-gateway":"위에서 작성한 foobar-user 애플리케이션에 대해 gateway 역할을 수행하는 모듈입니다.","buildgradlekts-1#build.gradle.kts":"// ...\r\n\r\nrepositories {\r\n  mavenCentral()\r\n}\r\n\r\nextra[\"springCloudVersion\"] = \"2023.0.1\"\r\n\r\ndependencies {\r\n  implementation(\"org.springframework.boot:spring-boot-starter-data-redis-reactive\")\r\n  implementation(\"org.springframework.cloud:spring-cloud-starter-gateway\")\r\n  compileOnly(\"org.projectlombok:lombok\")\r\n  annotationProcessor(\"org.projectlombok:lombok\")\r\n  testImplementation(\"org.springframework.boot:spring-boot-starter-test\")\r\n  testImplementation(\"io.projectreactor:reactor-test\")\r\n}\r\n\r\ndependencyManagement {\r\n  imports {\r\n    mavenBom(\"org.springframework.cloud:spring-cloud-dependencies:${property(\"springCloudVersion\")}\")\r\n  }\r\n}\r\n\r\n// ...","applicationyml#application.yml":"yml 파일 내에서 spring.cloud.gateway.routes[0].filters 내에 정의한 RequestRateLimiter 에 대한 args 중 key-resolver 에 대한 값인 \"#{@userIdAsKeyResolver}\" 값은 직접 정의한 Bean 입니다. 뒤에서 설명합니다.\nserver:\r\n  port: 9000\r\n\r\nspring:\r\n  data:\r\n    redis:\r\n      host: localhost\r\n      port: 26379\r\n      database: 0\r\n  cloud:\r\n    gateway:\r\n      routes:\r\n        - id: all\r\n          uri: http://localhost:8080\r\n          predicates:\r\n            - Path=/**\r\n          filters:\r\n            - name: RequestRateLimiter\r\n              args:\r\n                redis-rate-limiter.replenishRate: 20\r\n                redis-rate-limiter.burstCapacity: 100\r\n                redis-rate-limiter.requestedTokens: 3\r\n                key-resolver: \"#{@userIdAsKeyResolver}\"\nreplenishRate : 초당 버킷 회복 량을 의미합니다. 위에서는 100 을 지정했는데 1초 내에 어떤 요청이 90회 발생하면, 100을 채워주므로 1초 되에 다시 버킷이 100 으로 회복됩니다.\nburstCapacitiy : 버킷에 담을 수 있는 최대 양을 의미합니다.\nrequestedTokens : 요청 시에 소모할 토큰의 갯수를 의미합니다. 3으로 설정했으므로 요청 하나당 3 의 토큰이 소모됩니다.\nkey-resolver : \"#{@userIdKeyResolver}\" 로 지정해줬는데, Java Config 로 미리 정의해둔 \"userIdKeyResolver\" 라는 이름의 Bean 을 의미하는 SPEL 표현식입니다.","useridkeyresolver#UserIdKeyResolver":"사용자가 Request Header 에 전달한 USER-ID 라고 하는 헤더 값을 추출하기 위해 ServerWebExchange 내의 request 내의 Header 내에서 USER-ID 에 대한 값을 추출합니다.그리고 값이 정상일 경우 Mono<String> 을 return 하고 정상이 아닐 경우 Mono.error 를 리턴합니다.\npackage io.chagchagchag.example.gateway.resolver;\r\n\r\nimport java.util.Optional;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.cloud.gateway.filter.ratelimit.KeyResolver;\r\nimport org.springframework.stereotype.Component;\r\nimport org.springframework.web.server.ServerWebExchange;\r\nimport reactor.core.publisher.Mono;\r\n\r\n@Component(\"userIdAsKeyResolver\")\r\npublic class UserIdKeyResolver implements KeyResolver {\r\n  private final Logger logger = LoggerFactory.getLogger(UserIdKeyResolver.class);\r\n  @Override\r\n  public Mono<String> resolve(ServerWebExchange exchange) {\r\n    final String userId = exchange.getRequest()\r\n        .getHeaders()\r\n        .getFirst(\"USER-ID\");\r\n\r\n    return Optional.ofNullable(userId)\r\n        .map(Mono::justOrEmpty)\r\n        .orElseGet(() -> {\r\n          exchange.getResponse().setComplete();\r\n          logger.debug(\">>> 'USER-ID' is Empty\");\r\n          return Mono.error(new IllegalArgumentException(\"존재하지 않는 아이디입니다.\"));\r\n        });\r\n  }\r\n}","동작-확인-1#동작 확인":"먼저 foobar-user 를 기동시킵니다.\n그리고 foobar-gateway 를 기동시킵니다.\ncurl 명령으로 아래의 명령을 수행해서 Gateway 에서 정상적으로 동작하는지 확인합니다.\n$ curl -X GET localhost:9000/healthcheck/ready -H \"Content-Type: application/json\" -H \"USER-ID:'A'\"\r\nOK","curl-명령어#curl 명령어":"주로 http 파일을 쓰거나 springdoc 를 사용하는 편이지만, 간단한 테스트는 curl 로만 수행하는게 오히려 더 편할 때가 많습니다. 그래서 막간을 이용해서 curl 명령어를 정리해봅니다.curl 명령어 사용시 자주 사용하는 옵션은 3가지 입니다.\n-d, --data : \"data\" 를 의미합니다.\n-H, --header : \"header\" 를 의미합니다. 리퀘스트 전송시 헤더에 특정 값을 전달해야 할 경우 -H 를 지정해줍니다.\n-X, --request : 사용할 요청 메서드(GET, POST, PUT 등)를 명시해주기 위해 사용하는 옵션입니다.\n예를 들어 curl 명령어로 GET 요청을 하는데, 헤더에 USER-ID : A 를 전달해주려고 한다면 아래의 명령을 수행하면 됩니다.\n$ curl -X GET localhost:8080/healthcheck/ready -H \"Content-Type: application/json\" -d \"{\"USER-ID\": \"A\"}\"\r\nOK","e2e-테스트#e2e 테스트":"먼저 테스트를 위해 application.yml 내의 설정을 아래와 같이 바꿔줍니다. 그리고 Gateway Application 을 재기동해줍니다.\nserver:\r\n  port: 9000\r\n\r\nspring:\r\n  data:\r\n    redis:\r\n      host: localhost\r\n      port: 26379\r\n      database: 0\r\n  cloud:\r\n    gateway:\r\n      routes:\r\n        - id: all\r\n          uri: http://localhost:8080\r\n          predicates:\r\n            - Path=/**\r\n          filters:\r\n            - name: RequestRateLimiter\r\n              args:\r\n                redis-rate-limiter.replenishRate: 1\r\n                redis-rate-limiter.burstCapacity: 10\r\n                redis-rate-limiter.requestedTokens: 2\r\n                key-resolver: \"#{@userIdAsKeyResolver}\"\nburstCapacity 를 10초로 했고, requestedTokens 는 2로 설정해서 한 번의 요청에 토큰이 2개 소모되게끔 해주었습니다. 초당 버킷 회복량인 replenishRate 는 1 로 지정해서 버킷이 1초에 1정도가 회복되게끔 해줬습니다.curl 요청 테스트 스크립트 작성curl 요청을 0.5 초에 한번씩 30번 수행하는 스크립트입니다. replenishRate 는 1이므로 1초마다 1정도가 버킷에서 회복되고 requestesTokens 는 2 이므로 0.5초에 2번의 요청이 발생하면 4 개의 Token 이 1초에 한번씩 소모됩니다. 따라서 10 - 4 = 6 이 되고, 1초에 한번씩 버킷 사이즈는 6이 되었다가 다시 10으로 회복되는 방식입니다.curl 스크립트는 아래와 같습니다.\nfor((i=0; i<30; i++)); do\r\n  sleep .5\r\n  curl -X GET localhost:9000/healthcheck/ready -H \"Content-Type: application/json\" -H \"USER-ID:'A'\";\r\ndone\n결론적으로는 버킷이 1초에 2개의 요청을 수행하기에 총 15번의 요청이 성공하게 됩니다.수행 결과\n$ source curl-request-finite.sh \r\nOKOKOKOKOKOKOKOKOKOKOKOKOKOKOK"}},"/filter":{"title":"Filter","data":{}},"/rate-limiter/redis-docker-compose":{"title":"Redis Docker Compose","data":{"redis-docker-compose#Redis docker-compose":"예제로 사용할 Redis 의 docker-compose 파일입니다. 설명은 생략하겠습니다.\nversion: '3.8'\r\nservices:\r\n  redis:\r\n    image: redis:7.0\r\n    command: redis-server --port 6379\r\n    hostname: redis-localhost\r\n    labels:\r\n      - \"name=redis\"\r\n      - \"mode=standalone\"\r\n    ports:\r\n      - 26379:6379\r\n    depends_on: \r\n      - redis-commander\r\n    links:\r\n      - redis-commander\r\n    # networks:\r\n    #   - redis-local\r\n  redis-commander:\r\n    image: rediscommander/redis-commander:latest\r\n    hostname: redis-commander-localhost\r\n    restart: always\r\n    environment:\r\n      - REDIS_HOSTS=redis-localhost\r\n    ports:\r\n      - 38081:8081\r\n    # networks:\r\n    #   - redis-local\r\n# networks:\r\n#   redis-local:\r\n#     driver: bridge"}},"/rate-limiter/inside-redis-rate-limiter":{"title":"Inside Redis Rate Limiter","data":{"redisratelimiter-의-내부-동작#RedisRateLimiter 의 내부 동작":""}},"/rate-limiter/redis-rate-limiter":{"title":"Redis Rate Limiter","data":{}},"/rate-limiter/what-is-rate-limiter":{"title":"What Is Rate Limiter","data":{"rate-limiter-의-개념#Rate Limiter 의 개념":""}}}